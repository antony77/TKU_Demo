<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TEC.Core</name>
    </assembly>
    <members>
        <member name="T:TEC.Core.Collections.CollectionChangingEventArgs">
            <summary>
            在集合項目變更之前引發事件的參數
            </summary>
        </member>
        <member name="M:TEC.Core.Collections.CollectionChangingEventArgs.#ctor">
            <summary>
            初始化<see cref="T:TEC.Core.Collections.CollectionChangingEventArgs"/>類別的新執行個體，這個執行個體會描述<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>變更。
            </summary>
        </member>
        <member name="M:TEC.Core.Collections.CollectionChangingEventArgs.#ctor(System.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.IList)">
            <summary>
            初始化<see cref="T:TEC.Core.Collections.CollectionChangingEventArgs"/>類別的新執行個體，這個執行個體會描述多個項目的變更。
            </summary>
            <param name="action">造成事件的動作。可以設定為<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>、<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Add"/>或
            <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Remove"/>。</param>
            <param name="changingItems">即將受變更影響的項目</param>
        </member>
        <member name="M:TEC.Core.Collections.CollectionChangingEventArgs.#ctor(System.Collections.Specialized.NotifyCollectionChangedAction,System.Object)">
            <summary>
            初始化<see cref="T:TEC.Core.Collections.CollectionChangingEventArgs"/>類別的新執行個體，這個執行個體會描述一個項目的變更。
            </summary>
            <param name="action">造成事件的動作。可以設定為<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>、<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Add"/>或
            <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Remove"/>。</param>
            <param name="changingItem">即將受變更影響的項目</param>
            <exception cref="T:System.ArgumentException">如果 <paramref name="action"/> 不是 <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>、
            <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Add"/> 或 <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Remove"/>，或者
            <paramref name="action"/> 是 Reset 而且 <paramref name="changingItem"/> 不是 <c lang="C#">null</c>。</exception>
        </member>
        <member name="M:TEC.Core.Collections.CollectionChangingEventArgs.#ctor(System.Collections.IList,System.Collections.IList)">
            <summary>
            初始化<see cref="T:TEC.Core.Collections.CollectionChangingEventArgs"/>類別的新執行個體，這個執行個體會描述多個項目的<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Replace"/>變更。
            </summary>
            <param name="newItems">將取代原始項目的新項目</param>
            <param name="oldItems">將被取代的原始項目</param>
            <exception cref="T:System.ArgumentNullException">如果<paramref name="newItems"/>或<paramref name="oldItems"/>是 <c lang="C#">null</c>。</exception>
        </member>
        <member name="M:TEC.Core.Collections.CollectionChangingEventArgs.#ctor(System.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.IList,System.Int32)">
            <summary>
            初始化<see cref="T:TEC.Core.Collections.CollectionChangingEventArgs"/>類別的新執行個體，這個執行個體會描述多個項目或<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>變更。
            </summary>
            <param name="action">造成事件的動作。可以設定為<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>、<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Add"/>或
            <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Remove"/>。</param>
            <param name="changingItems">即將受變更影響的項目</param>
            <param name="startingIndex">即將發生變更的索引</param>
            <exception cref="T:System.ArgumentException">如果 <paramref name="action"/> 不是 <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>、
            <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Add"/> 或 <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Remove"/>，
            或者 <paramref name="action"/> 是 <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>，而且 <paramref name="changingItems"/> 不是 <c lang="C#">null</c>
            或 <paramref name="startingIndex"/> 不是 -1，又或者 <paramref name="action"/> 是 <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Add"/> 或 
            <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Remove"/>，而且 <paramref name="startingIndex"/> 小於 -1。</exception>
            <exception cref="T:System.ArgumentNullException">如果 <paramref name="action"/> 是 <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Add"/> 或
            <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Remove"/>，而且 <paramref name="changingItems"/> 是 <c lang="C#">null</c>。</exception>
        </member>
        <member name="M:TEC.Core.Collections.CollectionChangingEventArgs.#ctor(System.Collections.Specialized.NotifyCollectionChangedAction,System.Object,System.Int32)">
            <summary>
            初始化<see cref="T:TEC.Core.Collections.CollectionChangingEventArgs"/>類別的新執行個體，這個執行個體會描述一個項目的變更。
            </summary>
            <param name="action">造成事件的動作。可以設定為 <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>、
            <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Add"/> 或 <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Remove"/>。</param>
            <param name="changingItem">即將受變更影響的項目</param>
            <param name="index">發生變更的索引</param>
            <exception cref="T:System.ArgumentException">如果 <paramref name="action"/> 不是 <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>、
            <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Add"/> 或 <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Remove"/>
            ，或者 <paramref name="action"/> 是 <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>，而且 <paramref name="changingItem"/> 
            不是 <c lang="C#">null</c> 或 <paramref name="index"/> 不是 -1。</exception>
        </member>
        <member name="M:TEC.Core.Collections.CollectionChangingEventArgs.#ctor(System.Object,System.Object)">
            <summary>
            初始化<see cref="T:TEC.Core.Collections.CollectionChangingEventArgs"/>類別的新執行個體，這個執行個體會描述一個項目的<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Replace"/>變更。
            </summary>
            <param name="newItem">將取代原始項目的新項目</param>
            <param name="oldItem">將被取代的原始項目</param>
        </member>
        <member name="M:TEC.Core.Collections.CollectionChangingEventArgs.#ctor(System.Collections.IList,System.Collections.IList,System.Int32)">
            <summary>
            初始化<see cref="T:TEC.Core.Collections.CollectionChangingEventArgs"/>類別的新執行個體，這個執行個體會描述多個項目的<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Replace"/>變更。
            </summary>
            <param name="newItems">將取代原始項目的新項目</param>
            <param name="oldItems">將被取代的原始項目</param>
            <param name="startingIndex">被取代項目中第一個項目的索引</param>
            <exception cref="T:System.ArgumentNullException">如果 <paramref name="newItems"/> 或 <paramref name="oldItems"/> 是 <c lang="C#">null</c></exception>
        </member>
        <member name="M:TEC.Core.Collections.CollectionChangingEventArgs.#ctor(System.Collections.IList,System.Int32,System.Int32)">
            <summary>
            初始化<see cref="T:TEC.Core.Collections.CollectionChangingEventArgs"/>類別的新執行個體，這個執行個體會描述多個項目的<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Move"/>變更。
            </summary>
            <param name="changingItems">即將受變更影響的項目</param>
            <param name="index">即將變更之項目的新索引</param>
            <param name="oldIndex">即將變更之項目的舊索引</param>
            <exception cref="T:System.ArgumentException">如果 <paramref name="index"/> 小於 0</exception>
        </member>
        <member name="M:TEC.Core.Collections.CollectionChangingEventArgs.#ctor(System.Object,System.Int32,System.Int32)">
            <summary>
            初始化<see cref="T:TEC.Core.Collections.CollectionChangingEventArgs"/>類別的新執行個體，這個執行個體會描述多個項目的<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Move"/>變更。
            </summary>
            <param name="changingItem">即將受變更影響的項目</param>
            <param name="index">即將變更之項目的新索引</param>
            <param name="oldIndex">即將變更之項目的舊索引</param>
            <exception cref="T:System.ArgumentException">如果 <paramref name="index"/> 小於 0</exception>
        </member>
        <member name="M:TEC.Core.Collections.CollectionChangingEventArgs.#ctor(System.Object,System.Object,System.Int32)">
            <summary>
            初始化<see cref="T:TEC.Core.Collections.CollectionChangingEventArgs"/>類別的新執行個體，這個執行個體會描述一個項目的<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Replace"/>變更。
            </summary>
            <param name="newItem">將取代原始項目的新項目</param>
            <param name="oldItem">將被取代的原始項目</param>
            <param name="index">將被取代之項目的索引</param>
        </member>
        <member name="P:TEC.Core.Collections.CollectionChangingEventArgs.Action">
            <summary>
            取得即將造成事件的動作
            </summary>
        </member>
        <member name="P:TEC.Core.Collections.CollectionChangingEventArgs.NewItems">
            <summary>
            取得即將變更所涉及的新項目清單
            </summary>
        </member>
        <member name="P:TEC.Core.Collections.CollectionChangingEventArgs.NewStartingIndex">
            <summary>
            取得即將發生變更的索引
            </summary>
        </member>
        <member name="P:TEC.Core.Collections.CollectionChangingEventArgs.OldItems">
            <summary>
            取得即將受<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Replace"/>、
            <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Remove"/>或<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Move"/>動作影響的項目清單。
            </summary>
        </member>
        <member name="P:TEC.Core.Collections.CollectionChangingEventArgs.OldStartingIndex">
            <summary>
            取得即將發生<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Move"/>、
            <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Remove"/>或<see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Replace"/>動作的索引。
            </summary>
        </member>
        <member name="P:TEC.Core.Collections.CollectionChangingEventArgs.Cancel">
            <summary>
            設定或取得是否要取消動作
            </summary>
        </member>
        <member name="T:TEC.Core.Collections.Resources.CollectionChangingEventArgs">
            <summary>
              用於查詢當地語系化字串等的強類型資源類別。
            </summary>
        </member>
        <member name="P:TEC.Core.Collections.Resources.CollectionChangingEventArgs.ResourceManager">
            <summary>
              傳回這個類別使用的快取的 ResourceManager 執行個體。
            </summary>
        </member>
        <member name="P:TEC.Core.Collections.Resources.CollectionChangingEventArgs.Culture">
            <summary>
              覆寫目前執行緒的 CurrentUICulture 屬性，對象是所有
              使用這個強類型資源類別的資源查閱。
            </summary>
        </member>
        <member name="P:TEC.Core.Collections.Resources.CollectionChangingEventArgs.IndexCannotNegative">
            <summary>
              查詢類似 Index Cannot Be Negative 的當地語系化字串。
            </summary>
        </member>
        <member name="P:TEC.Core.Collections.Resources.CollectionChangingEventArgs.IndexRequiresMinus1">
            <summary>
              查詢類似 Reset Action Requires Index Minus 1 的當地語系化字串。
            </summary>
        </member>
        <member name="P:TEC.Core.Collections.Resources.CollectionChangingEventArgs.MustResetOrRemove">
            <summary>
              查詢類似 Must Be Reset Add Or Remove Action For Ctor 的當地語系化字串。
            </summary>
        </member>
        <member name="P:TEC.Core.Collections.Resources.CollectionChangingEventArgs.RequireNullItem">
            <summary>
              查詢類似 Reset Action Requires Null Item 的當地語系化字串。
            </summary>
        </member>
        <member name="T:TEC.Core.Collections.ThreadSafeObservableCollection`1">
            <summary>
            執行緒安全(Thread-Safe)。表示會在加入或移除項目時，或重新整理整份清單時，提供告知的動態資料集合。
            </summary>
            <typeparam name="T">集合中的項目型別</typeparam>
        </member>
        <member name="E:TEC.Core.Collections.ThreadSafeObservableCollection`1.CollectionChanged">
            <summary>
            發生於屬性值變更時
            </summary>
        </member>
        <member name="M:TEC.Core.Collections.ThreadSafeObservableCollection`1.#ctor">
            <summary>
            初始化<see cref="T:TEC.Core.Collections.ThreadSafeObservableCollection`1"/>類別的新執行個體
            </summary>
        </member>
        <member name="M:TEC.Core.Collections.ThreadSafeObservableCollection`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            初始化<see cref="T:TEC.Core.Collections.ThreadSafeObservableCollection`1"/>類別的新執行個體，這個類別包含自指定之集合複製過來的項目。
            </summary>
            <param name="collection">從中複製項目的集合</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/>參數不能為<c>null</c></exception>
        </member>
        <member name="M:TEC.Core.Collections.ThreadSafeObservableCollection`1.#ctor(System.Collections.Generic.List{`0})">
            <summary>
            初始化<see cref="T:TEC.Core.Collections.ThreadSafeObservableCollection`1"/>類別的新執行個體，其包含自指定清單複製過來的項目。
            </summary>
            <param name="list">從中複製項目的清單</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/>參數不能為<c>null</c></exception>
        </member>
        <member name="M:TEC.Core.Collections.ThreadSafeObservableCollection`1.BlockReentrancy_Changing">
            <summary>
            不允許變更這個集合的可重新進入嘗試
            </summary>
            <returns></returns>
        </member>
        <member name="M:TEC.Core.Collections.ThreadSafeObservableCollection`1.CheckReentrancy_Changing">
            <summary>
            檢查是否有變更這個集合的可重新進入嘗試
            </summary>
        </member>
        <member name="M:TEC.Core.Collections.ThreadSafeObservableCollection`1.ClearItems">
            <summary>
            移除集合中的所有項目
            </summary>
        </member>
        <member name="M:TEC.Core.Collections.ThreadSafeObservableCollection`1.InsertItem(System.Int32,`0)">
            <summary>
            將項目插入至位於指定索引處的集合中
            </summary>
            <param name="index">應該插入 <paramref name="item"/> 處之以零啟始的索引</param>
            <param name="item">要插入的物件</param>
        </member>
        <member name="M:TEC.Core.Collections.ThreadSafeObservableCollection`1.MoveItem(System.Int32,System.Int32)">
            <summary>
            將集合中之指定索引處的項目移至新位置。
            </summary>
            <param name="oldIndex">以零起始的索引，指定要移動之項目的位置。</param>
            <param name="newIndex">以零起始的索引，指定項目的新位置。</param>
        </member>
        <member name="M:TEC.Core.Collections.ThreadSafeObservableCollection`1.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            使用所提供的引數來引發<see cref="E:TEC.Core.Collections.ThreadSafeObservableCollection`1.CollectionChanged"/>事件
            </summary>
            <param name="e">所引發事件的引數</param>
        </member>
        <member name="M:TEC.Core.Collections.ThreadSafeObservableCollection`1.OnCollectionChanging(TEC.Core.Collections.CollectionChangingEventArgs)">
            <summary>
            使用所提供的引數來引發<see cref="E:TEC.Core.Collections.ThreadSafeObservableCollection`1.CollectionChanging"/>事件
            </summary>
            <param name="e">所引發事件的引數</param>
        </member>
        <member name="M:TEC.Core.Collections.ThreadSafeObservableCollection`1.RemoveItem(System.Int32)">
            <summary>
            移除位於集合中之指定索引處的項目
            </summary>
            <param name="index">要移除元素之以零起始的索引</param>
        </member>
        <member name="M:TEC.Core.Collections.ThreadSafeObservableCollection`1.SetItem(System.Int32,`0)">
            <summary>
            取代指定之索引處的項目
            </summary>
            <param name="index">要取代的項目之以零起始的索引</param>
            <param name="item">指定之索引處的項目新值</param>
        </member>
        <member name="E:TEC.Core.Collections.ThreadSafeObservableCollection`1.CollectionChanging">
            <summary>
            在將項目加入、移除、變更、移動，或整份清單重新整理之前發生。
            </summary>
        </member>
        <member name="T:TEC.Core.Collections.ThreadSafeObservableCollection`1.CollectionChangingEventHandler">
            <summary>
            表示處理<see cref="E:TEC.Core.Collections.ThreadSafeObservableCollection`1.CollectionChanging"/>事件的方法。
            </summary>
            <param name="sender">引發事件的物件</param>
            <param name="e">事件相關資訊</param>
        </member>
        <member name="T:TEC.Core.ComponentModel.NotifyPropertyChangedBase">
            <summary>
            告知用戶端，屬性值已變更的基底類別
            </summary>
        </member>
        <member name="M:TEC.Core.ComponentModel.NotifyPropertyChangedBase.notifyPropertyChanged(System.String)">
            <summary>
            引發屬性變更的通知
            </summary>
            <param name="propertyName">屬性名稱，若忽略此參數則為呼叫此方法的屬性名稱</param>
        </member>
        <member name="E:TEC.Core.ComponentModel.NotifyPropertyChangedBase.PropertyChanged">
            <summary>
            發生於屬性值變更時。
            </summary>
        </member>
        <member name="T:TEC.Core.ComponentModel.NotifyPropertyChangedBaseExtension">
            <summary>
            擴充類別:擴充<see cref="T:TEC.Core.ComponentModel.NotifyPropertyChangedBase"/>的靜態類別
            </summary>
        </member>
        <member name="M:TEC.Core.ComponentModel.NotifyPropertyChangedBaseExtension.notifyPropertyChanged``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            引發屬性變更的通知
            </summary>
            <typeparam name="T">繼承<see cref="T:TEC.Core.ComponentModel.NotifyPropertyChangedBase"/>的類別</typeparam>
            <typeparam name="TProperty">用於通知的屬性</typeparam>
            <param name="notifyPropertyChangedBase">繼承<see cref="T:TEC.Core.ComponentModel.NotifyPropertyChangedBase"/>的物件</param>
            <param name="property">屬性</param>
        </member>
        <member name="M:TEC.Core.ComponentModel.NotifyPropertyChangedBaseExtension.setPropertyAndNotifyOnChanged``4(``0,``3,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IEqualityComparer{``3})">
            <summary>
            設定<paramref name="newValue"/>至<paramref name="field"/>的運算式結果，並且判斷如果值有發生變更時，才會引發屬性變更的通知事件(<see cref="E:TEC.Core.ComponentModel.NotifyPropertyChangedBase.PropertyChanged"/>)
            </summary>
            <typeparam name="T">繼承<see cref="T:TEC.Core.ComponentModel.NotifyPropertyChangedBase"/>的類別</typeparam>
            <typeparam name="TProperty">用於通知的屬性</typeparam>
            <typeparam name="TField">要設定新值的欄位</typeparam>
            <typeparam name="TValue">要設定至<typeparamref name="TField"/>的新值</typeparam>
            <param name="notifyPropertyChangedBase">繼承<see cref="T:TEC.Core.ComponentModel.NotifyPropertyChangedBase"/>的物件</param>
            <param name="notifyProperty">用於通知變更的屬性</param>
            <param name="field">用於設定新值的欄位</param>
            <param name="newValue">要設定至指定欄位/屬性的值</param>
            <param name="valueEqualityComparer">用於比較值是否有改變的物件</param>
            <example>
            <code lang="C#">
            using TEC.Core.ComponentModel;
            public class TestClass : NotifyPropertyChangedBase
            {
                private int intValue = 0;
                private TestClass testClassTemp = null;
                public int IntValue
                {
                    set
                    {
                        this.setPropertyAndNotifyOnChanged(value, t =&gt; t.intValue, t =&gt; t.IntValue);
                    }
                    get
                    {
                        return this.intValue;
                    }
                }
                public TestClass TestClassTemp
                {
                    set
                    {
                        this.setPropertyAndNotifyOnChanged(value, t =&gt; t.testClassTemp, t =&gt; t.TestClassTemp);
                    }
                    get
                    {
                        return this.testClassTemp;
                    }
                }
            }
            </code>
            </example>
        </member>
        <member name="T:TEC.Core.ComponentModel.Resources.NotifyPropertyChangedBase">
            <summary>
              用於查詢當地語系化字串等的強類型資源類別。
            </summary>
        </member>
        <member name="P:TEC.Core.ComponentModel.Resources.NotifyPropertyChangedBase.ResourceManager">
            <summary>
              傳回這個類別使用的快取的 ResourceManager 執行個體。
            </summary>
        </member>
        <member name="P:TEC.Core.ComponentModel.Resources.NotifyPropertyChangedBase.Culture">
            <summary>
              覆寫目前執行緒的 CurrentUICulture 屬性，對象是所有
              使用這個強類型資源類別的資源查閱。
            </summary>
        </member>
        <member name="P:TEC.Core.ComponentModel.Resources.NotifyPropertyChangedBase.CannotFindMemberExpression">
            <summary>
              查詢類似 Cannot get the field/property from the expression. Expression: {0} 的當地語系化字串。
            </summary>
        </member>
        <member name="P:TEC.Core.ComponentModel.Resources.NotifyPropertyChangedBase.MemberTypeUnexpected">
            <summary>
              查詢類似 The parameter &quot;{0}&quot; type is not supported, expected: {1}, Actual: {2}. 的當地語系化字串。
            </summary>
        </member>
        <member name="T:TEC.Core.Data.Formula.FormulaCalculator`1">
            <summary>
            針對<typeparamref name="TCalculateValue"/>所使用的計算公式類別
            </summary>
            <typeparam name="TCalculateValue">當實作介面時需要運算的值類型，可以為自訂或內建型別</typeparam>
            <example>
            <para>ProductStorage.cs</para>
            <code lang="C#">
             [Serializable]
             public class ProductStorage : IEquatable&lt;ProductStorage&gt;
             {
                 public Guid Id { set; get; }
                 public int Number { set; get; }
                 public int Price { set; get; }
                 public float TotalPrice { set; get; }
                 public bool Equals(ProductStorage other)
                 {
                     return other.Id.Equals(this.Id) &amp;&amp;
                         other.Number == this.Number &amp;&amp;
                         other.Price == this.Price &amp;&amp;
                         other.TotalPrice == this.TotalPrice;
                 }
             }
            </code>
            <para>TenOffCondition.cs</para>
            <code lang="C#">
             public class TenOffCondition : IFormulaCondition&lt;ProductStorage&gt;
             {
                 public bool getIsConditionTenable(ProductStorage value, object parameter)
                 {
                     //必要時可透過parameter傳遞輔助參數
                     int totalPrice = value.Number * value.Price;
                     //當總價超過3000時，條件成立
                     if (totalPrice &gt; 3000)
                     {
                         return true;
                     }
                     return false;
                 }
                 public void applyFormulaCondition(ref ProductStorage value, System.Globalization.CultureInfo cultureInfo, object parameter)
                 {
                     //必要時可透過parameter傳遞輔助參數
                     //在條件成立時，才需要將公式結果套用
                     if (this.getIsConditionTenable(value, parameter))
                     {
                         int totalPrice = value.Number * value.Price;
                         value.TotalPrice = totalPrice * 0.9f;
                     }
                 }
             }
            </code>
            <para>Program.cs</para>
            <code lang="C#">
             class Program
             {
                 static void Main(string[] args)
                 {
                    FormulaCalculator&lt;ProductStorage&gt; priceFomulaCalculator = new FormulaCalculator&lt;ProductStorage&gt;();
                    ProductStorage productStorage = new ProductStorage() { Id = Guid.NewGuid(), Number = 500, Price = 2000 };
                    productStorage.TotalPrice = productStorage.Number * productStorage.Price;
                    //using TEC.Core.Threading.Tasks;
                    //套用公式
                    FormulaConditionAppliedResult&lt;ProductStorage&gt; resultStorage = priceFomulaCalculator.calculate(productStorage, new[] { new TenOffCondition() },
                        Core.Data.Formula.FormulaConditionsExecutionRule.ExecuteLoopUntilNoValueChangedInACycle, null).runAsyncTaskSynchronouslyWithReturn();
                    //以原本的物件為主，分別套用每個條件後傳回套用結果
                    List&lt;FormulaConditionAppliedResult&lt;ProductStorage&gt;&gt; resultStorageList =
                       priceFomulaCalculator.calculate(productStorage, new[] { new TenOffCondition(), new TenOffCondition() }, null, null).runAsyncTaskSynchronouslyWithReturn();
                 }
             }
            </code>
            </example>
        </member>
        <member name="M:TEC.Core.Data.Formula.FormulaCalculator`1.#ctor">
            <summary>
            初始化計算公式的類別
            </summary>
        </member>
        <member name="M:TEC.Core.Data.Formula.FormulaCalculator`1.#ctor(System.Int32)">
            <summary>
            初始化計算公式的類別，並執行模式為<see cref="F:TEC.Core.Data.Formula.FormulaConditionsExecutionRule.ExecuteLoopUntilNoValueChangedInACycle"/>時，重複重新執行公式清單的最大次數
            </summary>
            <param name="maximunExecutionLoops">重複執行公式的上限次數</param>
        </member>
        <member name="M:TEC.Core.Data.Formula.FormulaCalculator`1.calculate(`0,System.Collections.Generic.IList{TEC.Core.Data.Formula.IFormulaCondition{`0}},System.Globalization.CultureInfo,System.Object)">
            <summary>
            非同步將指定的<typeparamref name="TCalculateValue"/>套用每個條件後傳回套用的結果。
            </summary>
            <param name="source">要套用公式的<typeparamref name="TCalculateValue"/>參考</param>
            <param name="conditions">要套用的公式考慮清單</param>
            <param name="cultureInfo">套用公式所要使用的文化特性</param>
            <param name="parameter">套用公式要參考的參數</param>
            <returns>傳回公式套用後的結果清單，此結果將傳回複本物件</returns>
            <exception cref="T:System.ArgumentNullException">當執行公式的清單參考為<c>null</c>時擲出</exception>
        </member>
        <member name="M:TEC.Core.Data.Formula.FormulaCalculator`1.calculate(`0,System.Collections.Generic.IList{TEC.Core.Data.Formula.IFormulaCondition{`0}},TEC.Core.Data.Formula.FormulaConditionsExecutionRule,System.Globalization.CultureInfo,System.Object)">
            <summary>
            非同步將指定的<typeparamref name="TCalculateValue"/>套用公式並利用文化特性來運算結果。
            </summary>
            <param name="source">要套用公式的<typeparamref name="TCalculateValue"/>參考</param>
            <param name="conditions">要套用的公式考慮清單</param>
            <param name="cultureInfo">套用公式所要使用的文化特性</param>
            <param name="formulaConditionExecuteRule">套用模式</param>
            <param name="parameter">套用公式要參考的參數</param>
            <returns>傳回公式套用後的結果，此結果將傳回複本物件</returns>
            <exception cref="T:System.AggregateException">當執行模式為<see cref="F:TEC.Core.Data.Formula.FormulaConditionsExecutionRule.ExecuteLoopUntilNoValueChangedInACycle"/>時，超過重複重新執行公式清單的最大次數擲出</exception>
            <exception cref="T:System.ArgumentNullException">當執行公式的清單參考為<c>null</c>時擲出</exception>
        </member>
        <member name="M:TEC.Core.Data.Formula.FormulaCalculator`1.tryCalculate(`0,System.Collections.Generic.IList{TEC.Core.Data.Formula.IFormulaCondition{`0}},TEC.Core.Data.Formula.FormulaConditionsExecutionRule,System.Globalization.CultureInfo,System.Object,TEC.Core.Data.Formula.FormulaConditionAppliedResult{`0}@)">
            <summary>
            將指定的<typeparamref name="TCalculateValue"/>嘗試套用公式並利用文化特性來運算結果。
            </summary>
            <param name="source">要套用公式的<typeparamref name="TCalculateValue"/>參考</param>
            <param name="conditions">要套用的公式考慮清單</param>
            <param name="cultureInfo">套用公式所要使用的文化特性</param>
            <param name="result">套用的結果</param>
            <param name="formulaConditionExecuteRule">套用模式</param>
            <param name="parameter">套用公式要參考的參數</param>
            <returns>若有成功套用，則傳回<c>true</c>，若套用過程中發生任何錯誤，則傳回<c>false</c></returns>
        </member>
        <member name="P:TEC.Core.Data.Formula.FormulaCalculator`1.MaximunExecutionLoops">
            <summary>
            設定或取得當計算模式設定為<see cref="F:TEC.Core.Data.Formula.FormulaConditionsExecutionRule.ExecuteLoopUntilNoValueChangedInACycle"/>時，重複重新執行公式清單的最大次數，
            若超過此上限，將會擲出<see cref="T:System.AggregateException"/>例外
            </summary>
        </member>
        <member name="T:TEC.Core.Data.Formula.Resources.FormulaCalculator">
            <summary>
              用於查詢當地語系化字串等的強類型資源類別。
            </summary>
        </member>
        <member name="P:TEC.Core.Data.Formula.Resources.FormulaCalculator.ResourceManager">
            <summary>
              傳回這個類別使用的快取的 ResourceManager 執行個體。
            </summary>
        </member>
        <member name="P:TEC.Core.Data.Formula.Resources.FormulaCalculator.Culture">
            <summary>
              覆寫目前執行緒的 CurrentUICulture 屬性，對象是所有
              使用這個強類型資源類別的資源查閱。
            </summary>
        </member>
        <member name="P:TEC.Core.Data.Formula.Resources.FormulaCalculator.TooManyLoopInCalculation">
            <summary>
              查詢類似 There are more than {0} execution times in a calculate method call, if the situation is expected, please set the MaximunExecutionLoops property to another higher value than current value. 的當地語系化字串。
            </summary>
        </member>
        <member name="T:TEC.Core.Management.ApplicationLoader">
            <summary>
            應用程式讀取類別
            </summary>
            <example>
            <para>ApplicationLoaderService.cs</para>
            <code>
            public partial class ApplicationLoaderService : ServiceBase
            {
                public ApplicationLoaderService()
                {
                    InitializeComponent();
                }
                protected override void OnStart(string[] args)
                {
                    //此程式碼片段僅在"服務"運作中有效，並且執行身分應為 "Local System"
                    ApplicationLoader.ProcessInformation processInformation;
                    List&lt;WTSUser&gt; wtsUserList = TEC.Core.DirectoryService.WTSManagement.WTSUserLoader.getUsers("localhost");
                    foreach (WTSUser user in wtsUserList)
                    {
                        //將所有正在操作的工作階段開啟 cmd 
                        if (user.WTSConnectState == WTSConnectionState.WTSActive)
                        {
                            bool isSuccess = ApplicationLoader.runProcessBypassUAC(@"C:\Windows\System32\cmd.exe", Convert.ToUInt32(user.WTSSessionId), out processInformation);
                        }
                    }
                    base.OnStart(args);
                }
                protected override void OnStop()
                {
                    base.OnStop();
                }
            }
            </code>
            </example>
        </member>
        <member name="T:TEC.Core.Management.ApplicationLoader.ProcessInformation">
            <summary>
            在主處理緒建立新應用程式的資訊
            </summary>
            <remarks>原始結構 https://msdn.microsoft.com/zh-tw/library/windows/desktop/ms684873(v=vs.85).aspx </remarks>
        </member>
        <member name="F:TEC.Core.Management.ApplicationLoader.ProcessInformation.hProcess">
            <summary>
            A handle to the newly created process. The handle is used to specify the process in all functions that perform operations on the process object.
            </summary>
        </member>
        <member name="F:TEC.Core.Management.ApplicationLoader.ProcessInformation.hThread">
            <summary>
            A handle to the primary thread of the newly created process. The handle is used to specify the thread in all functions that perform operations on the thread object.
            </summary>
        </member>
        <member name="F:TEC.Core.Management.ApplicationLoader.ProcessInformation.dwProcessId">
            <summary>
            A value that can be used to identify a process. The value is valid from the time the process is created until all handles to the process are closed and the process object is freed; at this point, the identifier may be reused.
            </summary>
        </member>
        <member name="F:TEC.Core.Management.ApplicationLoader.ProcessInformation.dwThreadId">
            <summary>
            A value that can be used to identify a thread. The value is valid from the time the thread is created until all handles to the thread are closed and the thread object is freed; at this point, the identifier may be reused.
            </summary>
        </member>
        <member name="F:TEC.Core.Management.ApplicationLoader.ProcessInformation.sessionId">
            <summary>
            與此資訊相關的工作階段 ID
            </summary>
        </member>
        <member name="M:TEC.Core.Management.ApplicationLoader.runProcessBypassUAC(System.String,System.Nullable{System.UInt32},TEC.Core.Management.ApplicationLoader.ProcessInformation@)">
            <summary>
             以系統管理員模式執行指定路徑之應用程式，並忽略 UAC 控制。注意: 此程式碼應於 Windows Service 中以系統身分執行時有效。
            </summary>
            <param name="applicationName">要執行應用程式的完整路徑</param>
            <param name="procInfo">已建立的應用程式相關資訊</param>
            <param name="sessionId">工作階段 ID，若要以目前工作階段執行，則輸入 <c>null</c> 參考</param>
            <returns>回傳是否成功建立應用程式</returns>
            <remarks>若要取得所有可用的工作階段，請參考 TEC.Core.DirectoryService.WTSManagement.WTSUserLoader 之範例 </remarks>
            <example>
            <code lang="C#">
            bool isSuccess = ApplicationLoader.runProcessBypassUAC(@"C:\Windows\System32\cmd.exe", null, out processInformation);
            </code>
            </example>
        </member>
        <member name="T:TEC.Core.Management.CimConvertExtension">
            <summary>
            處理CIM與System類型的靜態擴充類別
            </summary>
        </member>
        <member name="M:TEC.Core.Management.CimConvertExtension.cimToSystemType(System.Management.PropertyData)">
            <summary>
            將CIM Type轉至System Type
            </summary>
            <param name="data">要轉換的類型</param>
            <returns></returns>
        </member>
        <member name="M:TEC.Core.Management.CimConvertExtension.cimToSystemValue(System.Management.PropertyData)">
            <summary>
            將CIM Value轉至System Value
            </summary>
            <param name="data">要轉換的值</param>
            <returns></returns>
        </member>
        <member name="T:TEC.Core.Management.ManagementObjectConverterExtension">
            <summary>
            讓管理物件轉換成特定定義物件的轉換類別
            </summary>
        </member>
        <member name="M:TEC.Core.Management.ManagementObjectConverterExtension.getWin32_NetworkAdapterConfigurationStorage(System.Management.ManagementObjectCollection)">
            <summary>
            由指定的<see cref="T:System.Management.ManagementObjectCollection"/>取得所有ClassName
            為Win32_NetworkAdapterConfiguration之<see cref="T:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration"/>清單
            </summary>
            <param name="managementObjectCollection">要轉換資料的Management Object</param>
            <returns>允許非同步作業並傳回<see cref="T:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration"/>清單之工作</returns>
            <example>
            此用法請參考<see cref="T:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration"/>之相關範例
            </example>
        </member>
        <member name="T:TEC.Core.Management.Net.IGMPLevel">
            <summary>
            IGMP Level列舉
            </summary>
        </member>
        <member name="F:TEC.Core.Management.Net.IGMPLevel.UnKnown">
            <summary>
            UnKnown
            </summary>
        </member>
        <member name="F:TEC.Core.Management.Net.IGMPLevel.NoMulticast">
            <summary>
            No Multicast
            </summary>
        </member>
        <member name="F:TEC.Core.Management.Net.IGMPLevel.IPMulticast">
            <summary>
            IP Multicast
            </summary>
        </member>
        <member name="F:TEC.Core.Management.Net.IGMPLevel.IPAndIGMP">
            <summary>
            IP and IGMP Multicast (default)
            </summary>
        </member>
        <member name="T:TEC.Core.Management.Net.IPXFrameType">
            <summary>
            Internetwork Packet Exchange (IPX) Frame Type 列舉
            </summary>
        </member>
        <member name="F:TEC.Core.Management.Net.IPXFrameType.UnKnown">
            <summary>
            UnKnown
            </summary>
        </member>
        <member name="F:TEC.Core.Management.Net.IPXFrameType.EthernetII">
            <summary>
            Ethernet II
            </summary>
        </member>
        <member name="F:TEC.Core.Management.Net.IPXFrameType.Ethernet802_3">
            <summary>
            Ethernet 802.3
            </summary>
        </member>
        <member name="F:TEC.Core.Management.Net.IPXFrameType.Ethernet802_2">
            <summary>
            Ethernet 802.2
            </summary>
        </member>
        <member name="F:TEC.Core.Management.Net.IPXFrameType.EthernetSNAP">
            <summary>
            Ethernet SNAP
            </summary>
        </member>
        <member name="F:TEC.Core.Management.Net.IPXFrameType.AUTO">
            <summary>
            Auto
            </summary>
        </member>
        <member name="T:TEC.Core.Management.Net.IPXMediaType">
            <summary>
            Internetwork Packet Exchange (IPX)  Media Type 列舉
            </summary>
        </member>
        <member name="F:TEC.Core.Management.Net.IPXMediaType.UnKnown">
            <summary>
            UnKnown
            </summary>
        </member>
        <member name="F:TEC.Core.Management.Net.IPXMediaType.Ethernet">
            <summary>
            Ethernet
            </summary>
        </member>
        <member name="F:TEC.Core.Management.Net.IPXMediaType.TokenRing">
            <summary>
            Token Ring
            </summary>
        </member>
        <member name="F:TEC.Core.Management.Net.IPXMediaType.FDDI">
            <summary>
            FDDI
            </summary>
        </member>
        <member name="F:TEC.Core.Management.Net.IPXMediaType.ARCNET">
            <summary>
            ARCNET
            </summary>
        </member>
        <member name="T:TEC.Core.Management.Net.TcpipNetbiosOptions">
            <summary>
            TCP/IP NETBIOS Options
            </summary>
        </member>
        <member name="F:TEC.Core.Management.Net.TcpipNetbiosOptions.UnKnown">
            <summary>
            UnKnown
            </summary>
        </member>
        <member name="F:TEC.Core.Management.Net.TcpipNetbiosOptions.EnableNetbiosViaDhcp">
            <summary>
            Enable Netbios Via Dhcp
            </summary>
        </member>
        <member name="F:TEC.Core.Management.Net.TcpipNetbiosOptions.EnableNetbios">
            <summary>
            Enable Netbios
            </summary>
        </member>
        <member name="F:TEC.Core.Management.Net.TcpipNetbiosOptions.DisableNetbios">
            <summary>
            Disable Netbios
            </summary>
        </member>
        <member name="T:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration">
            <summary>
            儲存網卡資訊的物件，目前尚無法取得VPN連線資訊
            </summary>
            <seealso cref="M:TEC.Core.Management.ManagementObjectConverterExtension.getWin32_NetworkAdapterConfigurationStorage(System.Management.ManagementObjectCollection)"/>
            <remarks>
            詳細資料請參考網址http://msdn.microsoft.com/en-us/library/windows/desktop/aa394217(v=vs.85).aspx &lt;br/&gt;
            Requirements&lt;br/&gt;
            Minimum supported client:Windows 2000 Professional&lt;br/&gt;
            Minimum supported server:Windows 2000 Server&lt;br/&gt;
            Namespace:\root\CIMV2&lt;br/&gt;
            MOF:Cimwin32.mof&lt;br/&gt;
            DLL:Cimwin32.dll&lt;br/&gt;
            </remarks>
            <example>
            <code lang="C#">
            //Reference System.Management
            ManagementScope managementScope = new ManagementScope(String.Format(@"\\{0}\root\CIMV2", Environment.MachineName));
            using (ManagementClass managementClass = new ManagementClass(managementScope, new ManagementPath("Win32_NetworkAdapterConfiguration"), null))
            {
                using (ManagementObjectCollection managementObjectCollection = managementClass.GetInstances())
                {
            
                    //此方式是以同步方是執行非同步的作法，若您需要使用await關鍵字，則做法如下
                    //List&lt;Win32_NetworkAdapterConfiguration&gt; result = await managementClass.GetInstances().getWin32_NetworkAdapterConfigurationStorage()
            
                    //using TEC.Core.Management; 
                    var task = managementClass.GetInstances().getWin32_NetworkAdapterConfigurationStorage();
                    List&lt;Win32_NetworkAdapterConfiguration&gt; result = task.Result;
                }
            }
            </code>
            </example>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.ArpAlwaysSourceRoute">
            <summary>
            設定或取得ArpAlwaysSourceRoute
            </summary>
            <remarks>
            If TRUE, TCP/IP transmits Address Resolution Protocol (ARP) queries with source routing enabled on Token Ring networks.
            By default (FALSE), ARP first queries without source routing, and then retries with source routing enabled if no reply is received. 
            Source routing allows the routing of network packets across different types of networks.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.ArpUseEtherSNAP">
            <summary>
            設定或取得ArpUseEtherSNAP
            </summary>
            <remarks>
            If TRUE, Ethernet packets follow the IEEE 802.3 Sub-Network Access Protocol (SNAP) encoding. 
            Setting this parameter to 1 forces TCP/IP to transmit Ethernet packets by using 802.3 SNAP encoding. 
            By default (FALSE), the stack transmits packets in DIX Ethernet format. Windows 2000 systems can receive both formats.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.Caption">
            <summary>
            設定或取得Caption
            </summary>
            <remarks>
            Description of the CIM_Setting object—a one-line string. This property is inherited from CIM_Setting.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.DatabasePath">
            <summary>
            設定或取得DatabasePath
            </summary>
            <remarks>
            Valid Windows file path to standard Internet database files (HOSTS, LMHOSTS, NETWORKS, and PROTOCOLS).
            The file path is used by the Windows Sockets interface. This property is only available on computer systems running Windows 2000.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.DeadGWDetectEnabled">
            <summary>
            設定或取得DeadGWDetectEnabled
            </summary>
            <remarks>
            If TRUE, dead gateway detection occurs. With this feature enabled,
            Transmission Control Protocol (TCP) asks Internet Protocol (IP) to change to a backup gateway
            if it retransmits a segment several times without receiving a response.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.DefaultIPGateway">
            <summary>
            設定或取得預設閘道
            </summary>
            <remarks>
            Array of IP addresses of default gateways that the computer system uses.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.DefaultTOS">
            <summary>
            設定或取得DefaultTOS
            </summary>
            <remarks>
            Default Type Of Service (TOS) value set in the header of outgoing IP packets.
            Request for Comments (RFC) 791 defines the values. Default: 0 (zero), Valid Range: 0 - 255.</remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.DefaultTTL">
            <summary>
            設定或取得DefaultTTL
            </summary>
            <remarks>
            Default Time To Live (TTL) value set in the header of outgoing IP packets. 
            The TTL specifies the number of routers an IP packet can pass through to reach its destination before being discarded. 
            Each router decrements by one the TTL count of a packet as it passes through and discards the packets—if the TTL is 0 (zero). Default: 32, Valid Range: 1 - 255.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.Description">
            <summary>
            設定或取得Description
            </summary>
            <remarks>
            Description of the CIM_Setting object. This property is inherited from CIM_Setting.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.DHCPEnabled">
            <summary>
            設定或取得DHCP是否已啟用
            </summary>
            <remarks>
            If TRUE, the dynamic host configuration protocol (DHCP) server automatically assigns an 
            IP address to the computer system when establishing a network connection.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.DHCPLeaseExpires">
            <summary>
            設定或取得DHCP租用到期時間
            </summary>
            <remarks>
            Expiration date and time for a leased IP address that was assigned to the computer 
            by the dynamic host configuration protocol (DHCP) server.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.DHCPLeaseObtained">
            <summary>
            設定或取得DHCP租約起始時間
            </summary>
            <remarks>
            Date and time the lease was obtained for the IP address assigned to the computer 
            by the dynamic host configuration protocol (DHCP) server.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.DHCPServer">
            <summary>
            設定或取得DHCP伺服器
            </summary>
            <remarks>
            IP address of the dynamic host configuration protocol (DHCP) server.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.DNSDomain">
            <summary>
            設定或取得DNS網域
            </summary>
            <remarks>
            Organization name followed by a period and an extension that indicates the type of organization, such as microsoft.com.
            The name can be any combination of the letters A through Z, the numerals 0 through 9, and the hyphen (-), plus the period (.) character used as a separator.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.DNSDomainSuffixSearchOrder">
            <summary>
            設定或取得DNS搜尋網域的順序
            </summary>
            <remarks>
            Array of DNS domain suffixes to be appended to the end of host names during name resolution. 
            When attempting to resolve a fully qualified domain name (FQDN) from a host-only name, the system will first append the local domain name.
            If this is not successful, the system will use the domain suffix list to create additional FQDNs in the order listed and query DNS servers for each.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.DNSEnabledForWINSResolution">
            <summary>
            設定或取得DNSEnabledForWINSResolution
            </summary>
            <remarks>
            If TRUE, the Domain Name System (DNS) is enabled for name resolution over Windows Internet Naming Service (WINS) resolution.
            If the name cannot be resolved using DNS, the name request is forwarded to WINS for resolution.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.DNSHostName">
            <summary>
            設定或取得DNS主機名稱
            </summary>
            <remarks>
            Host name used to identify the local computer for authentication by some utilities.
            Other TCP/IP-based utilities can use this value to acquire the name of the local computer.
            Host names are stored on DNS servers in a table that maps names to IP addresses for use by DNS.
            The name can be any combination of the letters A through Z, the numerals 0 through 9, and the hyphen (-), plus the period (.) character used as a separator.
            By default, this value is the Microsoft networking computer name, but the network administrator can assign another host name without affecting the computer name.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.DNSServerSearchOrder">
            <summary>
            設定或取得DNS Server的順序
            </summary>
            <remarks>
            Array of server IP addresses to be used in querying for DNS servers.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.DomainDNSRegistrationEnabled">
            <summary>
            設定或取得DomainDNSRegistrationEnabled
            </summary>
            <remarks>
            If TRUE, the IP addresses for this connection are registered in DNS under the domain name of this connection in addition to 
            being registered under the computer's full DNS name. The domain name of this connection is either set using the SetDNSDomain() method or assigned by DSCP.
            The registered name is the host name of the computer with the domain name appended.
            Windows 2000:  This property is not available. 
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.ForwardBufferMemory">
            <summary>
            設定或取得ForwardBufferMemory
            </summary>
            <remarks>
            Memory allocated by IP to store packet data in the router packet queue.
            When this buffer space is filled, the router begins discarding packets at random from its queue.
            Packet queue data buffers are 256 bytes in length, so the value of this parameter should be a multiple of 256.
            Multiple buffers are chained together for larger packets. The IP header for a packet is stored separately. 
            This parameter is ignored and no buffers are allocated if the IP router is not enabled. 
            The buffer size can range from the network MTU to a value smaller than 0xFFFFFFFF. Default: 74240 
            (fifty 1480-byte packets, rounded to a multiple of 256).
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.FullDNSRegistrationEnabled">
            <summary>
            設定或取得FullDNSRegistrationEnabled
            </summary>
            <remarks>
            If TRUE, the IP addresses for this connection are registered in DNS under the computer's full DNS name. 
            The full DNS name of the computer is displayed on the Network Identification tab in the System application in Control Panel.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.GatewayCostMetric">
            <summary>
            設定或取得GatewayCostMetric
            </summary>
            <remarks>
            Array of integer cost metric values (ranging from 1 to 9999) to be used 
            in calculating the fastest, most reliable, or least resource-intensive routes. 
            This argument has a one-to-one correspondence with the DefaultIPGateway property. 
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.IGMPLevel">
            <summary>
            設定或取得IGMPLevel
            </summary>
            <remarks>
            Extent to which the system supports IP multicast and participates in the Internet Group Management Protocol (IGMP).
            At level 0 (zero), the system provides no multicast support. 
            At level 1, the system may only send IP multicast packets. 
            At level 2, the system may send IP multicast packets and fully participate in IGMP to receive multicast packets.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.Index">
            <summary>
            設定或取得Index
            </summary>
            <remarks>
            Index number of the Windows network adapter configuration. 
            The index number is used when there is more than one configuration available.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.InterfaceIndex">
            <summary>
            設定或取得InterfaceIndex
            </summary>
            <remarks>
            Index value that uniquely identifies a local network interface.
            The value in this property is the same as the value in the InterfaceIndex property in the instance of Win32_IP4RouteTable that 
            represents the network interface in the route table.
            Windows XP and Windows 2000:  This property is not available. 
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.IPAddress">
            <summary>
            設定或取得IP位址
            </summary>
            <remarks>
            Array of all of the IP addresses associated with the current network adapter. 
            Starting with Windows Vista, this property can contain either IPv6 addresses or IPv4 addresses.
            For more information, see IPv6 and IPv4 Support in WMI.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.IPConnectionMetric">
            <summary>
            設定或取得IPConnectionMetric
            </summary>
            <remarks>
            Cost of using the configured routes for the IP bound adapter and is the weighted value for those routes in the IP routing table. 
            If there are multiple routes to a destination in the IP routing table, the route with the lowest metric is used. The default value is 1. 
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.IPEnabled">
            <summary>
            設定或取得網卡是否已啟用
            </summary>
            <remarks>
            If TRUE, TCP/IP is bound and enabled on this network adapter.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.IPFilterSecurityEnabled">
            <summary>
            設定或取得IPFilterSecurityEnabled
            </summary>
            <remarks>
            If TRUE, IP port security is enabled globally across all IP-bound network adapters and the security values 
            associated with individual network adapters are in effect. This property is used in conjunction with IPSecPermitTCPPorts, 
            IPSecPermitUDPPorts, and IPSecPermitIPProtocols. 
            If FALSE, IP filter security is disabled across all network adapters and allows all port and protocol traffic to flow unfiltered.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.IPSecPermitIPProtocols">
            <summary>
            設定或取得IPSecPermitIPProtocols
            </summary>
            <remarks>
            Array of the protocols permitted to run over the IP. The list of protocols is defined using the EnableIPSec method. 
            The list will either be empty or contain numeric values.
            A numeric value of 0 (zero) indicates access permission is granted for all protocols. 
            An empty string indicates that no protocols are permitted to run when IPFilterSecurityEnabled is TRUE.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.IPSecPermitTCPPorts">
            <summary>
            設定或取得IPSecPermitTCPPorts
            </summary>
            <remarks>
            Array of the ports that will be granted access permission for TCP. 
            The list of protocols is defined using the EnableIPSec method.
            The list will either be empty or contain numeric values. 
            A numeric value of 0 (zero)indicates access permission is granted for all ports. 
            An empty string indicates that no ports are granted access permission when IPFilterSecurityEnabled is TRUE.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.IPSecPermitUDPPorts">
            <summary>
            設定或取得IPSecPermitUDPPorts
            </summary>
            <remarks>
            Array of the ports that will be granted User Datagram Protocol (UDP) access permission.
            The list of protocols is defined using the EnableIPSec method.
            The list will either be empty or contain numeric values.
            A numeric value of 0 (zero) indicates access permission is granted for all ports. 
            An empty string indicates that no ports are granted access permission when IPFilterSecurityEnabled is TRUE.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.IPSubnet">
            <summary>
            設定或取得所有子網路遮罩
            </summary>
            <remarks>
            Array of all of the subnet masks associated with the current network adapter.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.IPUseZeroBroadcast">
            <summary>
            設定或取得IPUseZeroBroadcast
            </summary>
            <remarks>
            If TRUE, IP zeros-broadcasts are used (0.0.0.0), and the system uses ones-broadcasts (255.255.255.255).
            Computer systems generally use ones-broadcasts, but those derived from BSD implementations use zeros-broadcasts. 
            Systems that do not use that same broadcasts will not interoperate on the same network. The default is FALSE.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.IPXAddress">
            <summary>
            設定或取得IPXAddress
            </summary>
            <remarks>
            Starting with Windows Vista, the Internetwork Packet Exchange (IPX) technology is 
            no longer supported and this property does not contain useful data.
            
            Windows Server 2003, Windows XP, and Windows 2000:  Internetwork Packet Exchange (IPX) address of the network adapter. 
            The IPX address identifies a computer system on a network using the IPX protocol.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.IPXEnabled">
            <summary>
            設定或取得IPXEnabled
            </summary>
            <remarks>
            Starting with Windows Vista, the Internetwork Packet Exchange (IPX) technology is 
            no longer supported and this property does not contain useful data.
            
            Windows Server 2003, Windows XP, and Windows 2000:  If TRUE, 
            the or Internetwork Packet Exchange (IPX) protocol is bound and enabled for this adapter.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.IPXFrameType">
            <summary>
            設定或取得IPXFrameType
            </summary>
            <remarks>
            Starting with Windows Vista, the Internetwork Packet Exchange (IPX) technology is
            no longer supported and this property does not contain useful data.
            
            Windows Server 2003, Windows XP, and Windows 2000:  Array of frame-type identifiers.
            The values in this array correspond to the elements in IPXNetworkNumber.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.IPXMediaType">
            <summary>
            設定或取得IPXMediaType
            </summary>
            <remarks>
            Starting with Windows Vista, the Internetwork Packet Exchange (IPX) technology is 
            no longer supported and this property does not contain useful data.
            
            Windows Server 2003, Windows XP, and Windows 2000:  Internetwork Packet Exchange (IPX) media-type identifier.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.IPXNetworkNumber">
            <summary>
            設定或取得IPXNetworkNumber
            </summary>
            <remarks>
            Starting with Windows Vista, the Internetwork Packet Exchange (IPX) technology is 
            no longer supported and this property does not contain useful data.
            
            Windows Server 2003, Windows XP, and Windows 2000:  
            Array of characters that uniquely identifies a frame or network adapter combination on the computer system.
            The NetWare Link (NWLink) IPX/SPX-compatible transport in Windows 2000 and later use two distinctly different types of network numbers.
            This number is sometimes referred to as the external network number. It must be unique for each network segment. 
            The order in this string list will correspond item-for-item with the elements in the IPXFrameType property.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.IPXVirtualNetNumber">
            <summary>
            設定或取得IPXVirtualNetNumber
            </summary>
            <remarks>
            Starting with Windows Vista, the Internetwork Packet Exchange (IPX) technology is no 
            longer supported and this property does not contain useful data.
            
            Windows Server 2003, Windows XP, and Windows 2000:  Unique identifier of the computer system on the network.
            It is represented in the form of an eight-character hexadecimal digit.
            Windows 2000 uses the virtual network number (also known as an internal network number) for internal routing.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.KeepAliveInterval">
            <summary>
            設定或取得KeepAliveInterval(Milliseconds)
            </summary>
            <remarks>
            The KeepAliveTime property indicates how often the TCP attempts to verify that an 
            idle connection is still intact by sending a Keep Alive Packet. A remote system that is reachable will 
            acknowledge the keep alive transmission. Keep Alive packets are not sent by default. 
            This feature may be enabled in a connection by an application. Default: 7,200,000 (two hours).
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.KeepAliveTime">
            <summary>
            設定或取得KeepAliveTime(Milliseconds)
            </summary>
            <remarks>
            The KeepAliveTime property indicates how often the TCP attempts to verify that an idle connection is 
            still intact by sending a Keep Alive Packet. A remote system that is reachable will acknowledge the keep alive transmission.
            Keep Alive packets are not sent by default. 
            This feature may be enabled in a connection by an application. Default: 7,200,000 (two hours).
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.MACAddress">
            <summary>
            設定或取得MAC位址
            </summary>
            <remarks>
            Media Access Control (MAC) address of the network adapter.
            A MAC address is assigned by the manufacturer to uniquely identify the network adapter.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.MTU">
            <summary>
            設定或取得MTU
            </summary>
            <remarks>
            Overrides the default Maximum Transmission Unit (MTU) for a network interface. 
            The MTU is the maximum packet size (including the transport header) that the transport will transmit over the underlying network.
            The IP datagram can span multiple packets. 
            The range of this value spans the minimum packet size (68) to the MTU supported by the underlying network.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.NumForwardPackets">
            <summary>
            設定或取得NumForwardPackets
            </summary>
            <remarks>
            Number of IP packet headers allocated for the router packet queue. 
            When all headers are in use, the router will begin to discard packets from the queue at random.
            This value should be at least as large as the ForwardBufferMemory value divided by the maximum IP data size 
            of the networks connected to the router. 
            It should be no larger than the ForwardBufferMemory value divided by 256, since at least 256 bytes 
            of forward buffer memory are used for each packet. 
            The optimal number of forward packets for a given ForwardBufferMemory size depends on the type of traffic on the network. 
            It will be somewhere between these two values. 
            If the router is not enabled, this parameter is ignored and no headers are allocated. 
            Default: 50, Valid Range: 1 - 0xFFFFFFFE.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.PMTUBHDetectEnabled">
            <summary>
            設定或取得PMTUBHDetectEnabled
            </summary>
            <remarks>
            If TRUE, detection of black hole routers occurs while TCP discovers the path of the Maximum Transmission Unit. 
            A black hole router does not return ICMP Destination Unreachable messages when 
            it needs to fragment an IP datagram with the Don't Fragment bit set. 
            TCP depends on receiving these messages to perform Path MTU Discovery. 
            With this feature enabled, TCP will try to send segments without the Don't Fragment bit set
            if several retransmissions of a segment go unacknowledged. 
            If the segment is acknowledged as a result, 
            the MSS will be decreased and the Don't Fragment bit will be set in future packets on the connection.
            Enabling black hole detection increases the maximum number of retransmissions performed for a given segment.
            The default value of this property is FALSE.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.PMTUDiscoveryEnabled">
            <summary>
            設定或取得PMTUDiscoveryEnabled
            </summary>
            <remarks>
            If TRUE, the Maximum Transmission Unit (MTU) path is discovered over the path to a remote host. 
            By discovering the MTU path and limiting TCP segments to this size, 
            TCP can eliminate fragmentation at routers along the path that connect networks with different MTUs.
            Fragmentation adversely affects TCP throughput and network congestion. 
            Setting this parameter to FALSE causes an MTU of 576 bytes to be used for all connections that 
            are not to machines on the local subnet.
            The default is TRUE.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.ServiceName">
            <summary>
            設定或取得ServiceName
            </summary>
            <remarks>
            Service name of the network adapter. This name is usually shorter than the full product name.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.SettingID">
            <summary>
            設定或取得SettingID
            </summary>
            <remarks>
            Identifier by which the CIM_Setting object is known. This property is inherited from CIM_Setting.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.TcpipNetbiosOptions">
            <summary>
            設定或取得TcpipNetbiosOptions
            </summary>
            <remarks>
            Bitmap of the possible settings related to NetBIOS over TCP/IP. 
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.TcpMaxConnectRetransmissions">
            <summary>
            設定或取得TcpMaxConnectRetransmissions
            </summary>
            <remarks>
            Number of times TCP attempts to retransmit a Connect Request before terminating the connection.
            The initial retransmission timeout is 3 seconds. The retransmission timeout doubles for each attempt.
            Default: 3, Valid Range: 0 - 0xFFFFFFFF.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.TcpMaxDataRetransmissions">
            <summary>
            設定或取得TcpMaxDataRetransmissions
            </summary>
            <remarks>
            Number of times TCP retransmits an individual data segment (nonconnect segment) before terminating the connection.
            The retransmission timeout doubles with each successive retransmission on a connection.
            Default: 5, Valid Range: 0 - 0xFFFFFFFF.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.TcpNumConnections">
            <summary>
            設定或取得TcpNumConnections
            </summary>
            <remarks>
            Maximum number of connections that TCP can have open simultaneously. 
            Default: 0xFFFFFE, Valid Range: 0 - 0xFFFFFE.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.TcpUseRFC1122UrgentPointer">
            <summary>
            設定或取得TcpUseRFC1122UrgentPointer
            </summary>
            <remarks>
            If TRUE, TCP uses the RFC 1122 specification for urgent data. 
            If FALSE (default), TCP uses the mode used by Berkeley Software Design (BSD) derived systems.
            The two mechanisms interpret the urgent pointer differently and are not interoperable. 
            The default value is FALSE.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.TcpWindowSize">
            <summary>
            設定或取得TcpWindowSize
            </summary>
            <remarks>
            Maximum TCP Receive Window size offered by the system. 
            The Receive Window specifies the number of bytes a sender may transmit without receiving an acknowledgment. 
            In general, larger receiving windows will improve performance over high-delay and high-bandwidth networks. 
            For efficiency, the receiving window should be an even multiple of the TCP Maximum Segment Size (MSS). 
            Default: Four times the maximum TCP data size or an even multiple of TCP data size rounded up to the nearest multiple of 8192. 
            Ethernet networks default to 8760. Valid range: 0 - 65535.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.WINSEnableLMHostsLookup">
            <summary>
            設定或取得WINSEnableLMHostsLookup
            </summary>
            <remarks>
            If TRUE, local lookup files are used. Lookup files will contain a map of IP addresses to host names. 
            If they exist on the local system, they will be found in %SystemRoot%\system32\drivers\etc.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.WINSHostLookupFile">
            <summary>
            設定或取得WINSHostLookupFile
            </summary>
            <remarks>
            Path to a WINS lookup file on the local system. This file will contain a map of IP addresses to host names.
            If the file specified in this property is found, it will be copied to the 
            %SystemRoot%\system32\drivers\etc folder of the local system.
            Valid only if the WINSEnableLMHostsLookup property is TRUE.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.WINSPrimaryServer">
            <summary>
            設定或取得WINSPrimaryServer
            </summary>
            <remarks>
            IP address for the primary WINS server.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.WINSScopeID">
            <summary>
            設定或取得WINSScopeID
            </summary>
            <remarks>
            Value appended to the end of the NetBIOS name that isolates a group of computer systems communicating with only each other.
            It is used for all NetBIOS transactions over TCP/IP communications from that computer system.
            Computers configured with identical scope identifiers are able to communicate with this computer.
            TCP/IP clients with different scope identifiers disregard packets from computers with this scope identifier. 
            Valid only when the EnableWINS method executes successfully.
            </remarks>
        </member>
        <member name="P:TEC.Core.Management.Net.Win32_NetworkAdapterConfiguration.WINSSecondaryServer">
            <summary>
            設定或取得WINSSecondaryServer
            </summary>
            <remarks>
            IP address for the secondary WINS server.
            </remarks>
        </member>
        <member name="T:TEC.Core.Management.OSVersionInfo">
             <summary>
             Provides detailed information about the host operating system.
             </summary>
             <remarks>
             StringBuilder sb = new StringBuilder(String.Empty);
             sb.AppendLine("Operation System Information");
             sb.AppendLine("----------------------------");
             sb.AppendLine(String.Format("Name = {0}", OSVersionInfo.Name));
             sb.AppendLine(String.Format("Edition = {0}", OSVersionInfo.Edition));
             if (OSVersionInfo.ServicePack!=string.Empty)
             {
               sb.AppendLine(String.Format("Service Pack = {0}", OSVersionInfo.ServicePack));
             }
             else
             {
               sb.AppendLine("Service Pack = None");
             }
             sb.AppendLine(String.Format("Version = {0}", OSVersionInfo.VersionString));
             sb.AppendLine(String.Format("ProcessorBits = {0}", OSVersionInfo.ProcessorBits));
             sb.AppendLine(String.Format("OSBits = {0}", OSVersionInfo.OSBits));
             sb.AppendLine(String.Format("ProgramBits = {0}", OSVersionInfo.ProgramBits));
             textBox1.Text = sb.ToString();
            
             http://www.codeproject.com/Articles/73000/Getting-Operating-System-Version-Info-Even-for-Win
             </remarks>
        </member>
        <member name="P:TEC.Core.Management.OSVersionInfo.ProgramBits">
            <summary>
            取得目前應用程式的位元架構
            </summary>
        </member>
        <member name="P:TEC.Core.Management.OSVersionInfo.OSBits">
            <summary>
            取得作業系統位元
            </summary>
        </member>
        <member name="P:TEC.Core.Management.OSVersionInfo.ProcessorBits">
            <summary>
            取得處理器的位元架構
            </summary>
        </member>
        <member name="P:TEC.Core.Management.OSVersionInfo.Edition">
            <summary>
            取得目前電腦的作業系統版本
            </summary>
        </member>
        <member name="P:TEC.Core.Management.OSVersionInfo.Name">
            <summary>
            取得目前電腦上安裝作業系統的名稱
            </summary>
        </member>
        <member name="P:TEC.Core.Management.OSVersionInfo.ServicePack">
            <summary>
            取得目前電腦上作業系統的service pack 資訊
            </summary>
        </member>
        <member name="P:TEC.Core.Management.OSVersionInfo.BuildVersion">
            <summary>
            取得目前 System.Version 物件的版本號碼之組建元件值。
            </summary>
        </member>
        <member name="P:TEC.Core.Management.OSVersionInfo.VersionString">
            <summary>
            取得目前電腦中作業系統的完整版本號字串
            </summary>
        </member>
        <member name="P:TEC.Core.Management.OSVersionInfo.Version">
            <summary>
            取得辨識這個作業系統的 System.Version 物件。
            </summary>
        </member>
        <member name="P:TEC.Core.Management.OSVersionInfo.MajorVersion">
            <summary>
            取得目前 System.Version 物件的版本號碼之主要元件值
            </summary>
        </member>
        <member name="P:TEC.Core.Management.OSVersionInfo.MinorVersion">
            <summary>
            取得目前 System.Version 物件的版本號碼之次要元件值
            </summary>
        </member>
        <member name="P:TEC.Core.Management.OSVersionInfo.RevisionVersion">
            <summary>
            取得目前 System.Version 物件的版本號碼之修訂元件值
            </summary>
        </member>
        <member name="M:TEC.Core.Management.OSVersionInfo.GetIsWow64ProcessDelegate">
            <summary>
            取得是否使用WOW64的委派
            </summary>
            <returns></returns>
        </member>
        <member name="P:TEC.Core.Management.OSVersionInfo.Is32BitProcessOn64BitProcessor">
            <summary>
            取得是否在64位元處理器上執行32位元系統
            </summary>
            <returns></returns>
        </member>
        <member name="T:TEC.Core.Management.OSVersionInfo.SoftwareArchitecture">
            <summary>
            軟體位元架構
            </summary>
        </member>
        <member name="F:TEC.Core.Management.OSVersionInfo.SoftwareArchitecture.Unknown">
            <summary>
            未知
            </summary>
        </member>
        <member name="F:TEC.Core.Management.OSVersionInfo.SoftwareArchitecture.Bit32">
            <summary>
            32位元
            </summary>
        </member>
        <member name="F:TEC.Core.Management.OSVersionInfo.SoftwareArchitecture.Bit64">
            <summary>
            64位元
            </summary>
        </member>
        <member name="T:TEC.Core.Management.OSVersionInfo.ProcessorArchitecture">
            <summary>
            處理器位元架構
            </summary>
        </member>
        <member name="F:TEC.Core.Management.OSVersionInfo.ProcessorArchitecture.Unknown">
            <summary>
            未知
            </summary>
        </member>
        <member name="F:TEC.Core.Management.OSVersionInfo.ProcessorArchitecture.Bit32">
            <summary>
            32位元
            </summary>
        </member>
        <member name="F:TEC.Core.Management.OSVersionInfo.ProcessorArchitecture.Bit64">
            <summary>
            64位元
            </summary>
        </member>
        <member name="F:TEC.Core.Management.OSVersionInfo.ProcessorArchitecture.Itanium64">
            <summary>
            IA64
            </summary>
        </member>
        <member name="T:TEC.Core.Net.ComputerDomain">
            <summary>
            查詢電腦網資訊的靜態類別
            </summary>
        </member>
        <member name="P:TEC.Core.Net.ComputerDomain.ErrorSuccess">
            <summary>
            取得方法完成應傳回的值(目前為0)
            </summary>
        </member>
        <member name="P:TEC.Core.Net.ComputerDomain.NetJoinStatus">
            <summary>
            取得目前電腦的網域狀態
            </summary>
            <exception cref="T:System.InvalidOperationException">當無法取得電腦網域資訊時會擲出的例外</exception>
        </member>
        <member name="T:TEC.Core.Net.NetJoinStatus">
            <summary>
            電腦主機加入網域的狀態列舉
            </summary>
        </member>
        <member name="F:TEC.Core.Net.NetJoinStatus.NetSetupUnknownStatus">
            <summary>
            未知
            </summary>
        </member>
        <member name="F:TEC.Core.Net.NetJoinStatus.NetSetupUnjoined">
            <summary>
            尚未加入
            </summary>
        </member>
        <member name="F:TEC.Core.Net.NetJoinStatus.NetSetupWorkgroupName">
            <summary>
            已設定WorkGroup
            </summary>
        </member>
        <member name="F:TEC.Core.Net.NetJoinStatus.NetSetupDomainName">
            <summary>
            已設定Domain
            </summary>
        </member>
        <member name="T:TEC.Core.Net.NetworkShareAccesser">
            <summary>
            用於存取網路共享資源的存取器
            </summary>
            <remarks>
            注意：於多執行緒的情況，無法在呼叫<see cref="M:TEC.Core.Net.NetworkShareAccesser.Dispose"/>之前再次呼叫
            <see cref="M:TEC.Core.Net.NetworkShareAccesser.connectToNetworkShare(System.String)"/>/<see cref="M:TEC.Core.Net.NetworkShareAccesser.connectToNetworkShare(System.String,System.String,System.String)"/>/<see cref="M:TEC.Core.Net.NetworkShareAccesser.connectToNetworkShareWithPrompt(System.String)"/>
            等方法。如要使用其他使用者登入同一個網路路徑，請確定已將現有連線呼叫<see cref="M:TEC.Core.Net.NetworkShareAccesser.Dispose"/>後再進行其他使用者的連線作業。
            </remarks>
        </member>
        <member name="M:TEC.Core.Net.NetworkShareAccesser.Finalize">
            <summary>
            解構物件
            </summary>
        </member>
        <member name="M:TEC.Core.Net.NetworkShareAccesser.#ctor(System.String)">
            <summary>
            初始化存取網路共享資源的存取器
            </summary>
            <param name="uncPath">要存取的UNC網路路徑(如 @"\\ComputerName\Path" )</param>
        </member>
        <member name="M:TEC.Core.Net.NetworkShareAccesser.connectToNetworkShareInternal">
            <summary>
            以目前使用者認證連接<see cref="P:TEC.Core.Net.NetworkShareAccesser.UncPath"/>指定的網路共享資源，當目前使用者沒有權限存取時，請嘗試使用<see cref="M:TEC.Core.Net.NetworkShareAccesser.connectToNetworkShareWithPromptInternal"/>提示使用者輸入帳號密碼，
            或使用附帶帳號密碼的多載(<see cref="M:TEC.Core.Net.NetworkShareAccesser.connectToNetworkShareInternal(System.String,System.String)"/>)以存取指定的路徑。
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">連接期間若有任何錯誤將以此例外擲出</exception>
        </member>
        <member name="M:TEC.Core.Net.NetworkShareAccesser.connectToNetworkShareWithPromptInternal">
            <summary>
            以互動模式(提示使用者)連接<see cref="P:TEC.Core.Net.NetworkShareAccesser.UncPath"/>指定的網路共享資源
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">連接期間若有任何錯誤將以此例外擲出</exception>
        </member>
        <member name="M:TEC.Core.Net.NetworkShareAccesser.connectToNetworkShareInternal(System.String,System.String)">
            <summary>
            以指定的帳號密碼連接<see cref="P:TEC.Core.Net.NetworkShareAccesser.UncPath"/>指定的網路共享資源
            </summary>
            <param name="userName">使用者名稱</param>
            <param name="password">密碼</param>
            <exception cref="T:System.ComponentModel.Win32Exception">連接期間若有任何錯誤將以此例外擲出</exception>
        </member>
        <member name="M:TEC.Core.Net.NetworkShareAccesser.disconnectFromShare">
            <summary>
            中斷<see cref="P:TEC.Core.Net.NetworkShareAccesser.UncPath"/>指定的UNC網路共享資源
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">連接期間若有任何錯誤將以此例外擲出</exception>
        </member>
        <member name="M:TEC.Core.Net.NetworkShareAccesser.Dispose(System.Boolean)">
            <summary>
            釋放目前物件的資源
            </summary>
            <param name="isDisposing">是否開始處理物件的資源釋放行為</param>
        </member>
        <member name="M:TEC.Core.Net.NetworkShareAccesser.Dispose">
            <summary>
            強制中斷目前<see cref="P:TEC.Core.Net.NetworkShareAccesser.UncPath"/>連線並執行與釋放 (Free)、釋放 (Release) 或重設 Unmanaged 資源相關聯之應用程式定義的工作。
            </summary>
        </member>
        <member name="M:TEC.Core.Net.NetworkShareAccesser.connectToNetworkShare(System.String,System.String,System.String)">
            <summary>
            以帳號密碼讀取指定UNC路徑的位置，並建立其存取管理員的執行個體，當此物件不再被使用時，請呼叫<see cref="M:TEC.Core.Net.NetworkShareAccesser.Dispose"/>方法釋放其存取資源。
            </summary>
            <param name="uncPath">要存取的UNC網路路徑</param>
            <param name="userName">用於存取其網路路徑的使用者名稱</param>
            <param name="password">用於存取其網路路徑使用者名稱(<paramref name="userName"/>)所對應的密碼</param>
            <returns>傳回產生指定路徑的網路資源存取執行個體的作業</returns>
            <exception cref="T:System.ComponentModel.Win32Exception">連接期間若有任何錯誤將以此例外擲出</exception>
            <example>
            <code lang="C#">
            //using TEC.Core.Net
            using (NetworkShareAccesser networkShareAccesser = NetworkShareAccesser.connectToNetworkShare(@"\\IPorCompName\SomeFolder", "UserName", "Password").Result)
            {
                using (System.IO.FileStream fs = System.IO.File.Create(@"\\IPorCompName\SomeFolder\file.txt"))
                {
                    //Do someThing
                }
            };
            </code>
            </example>
        </member>
        <member name="M:TEC.Core.Net.NetworkShareAccesser.connectToNetworkShare(System.String)">
            <summary>
            以目前的使用者認證讀取指定UNC路徑的位置，並建立其存取管理員的執行個體，當此物件不再被使用時，請呼叫<see cref="M:TEC.Core.Net.NetworkShareAccesser.Dispose"/>方法釋放其存取資源。
            </summary>
            <param name="uncPath">要存取的UNC網路路徑</param>
            <returns>傳回產生指定路徑的網路資源存取執行個體的作業</returns>
            <example>
            <exception cref="T:System.ComponentModel.Win32Exception">連接期間若有任何錯誤將以此例外擲出</exception>
            <code lang="C#">
            //using TEC.Core.Net
            using (NetworkShareAccesser networkShareAccesser = NetworkShareAccesser.connectToNetworkShare(@"\\IPorCompName\SomeFolder").Result)
            {
                using (System.IO.FileStream fs = System.IO.File.Create(@"\\IPorCompName\SomeFolder\file.txt"))
                {
                    //Do someThing
                }
            };
            </code>
            </example>
        </member>
        <member name="M:TEC.Core.Net.NetworkShareAccesser.connectToNetworkShareWithPrompt(System.String)">
            <summary>
            以互動式視窗提示使用者輸入帳號密碼，存取指定UNC路徑的位置，並建立其存取管理員的執行個體，當此物件不再被使用時，請呼叫<see cref="M:TEC.Core.Net.NetworkShareAccesser.Dispose"/>方法釋放其存取資源。
            </summary>
            <param name="uncPath">要存取的UNC網路路徑</param>
            <exception cref="T:System.ComponentModel.Win32Exception">連接期間若有任何錯誤將以此例外擲出</exception>
            <returns>傳回指定路徑的網路資源存取執行個體</returns>
            <example>
            <code lang="C#">
            //using TEC.Core.Net
            using (NetworkShareAccesser networkShareAccesser = NetworkShareAccesser.connectToNetworkShareWithPrompt(@"\\IPorCompName\SomeFolder"))
            {
                using (System.IO.FileStream fs = System.IO.File.Create(@"\\IPorCompName\SomeFolder\file.txt"))
                {
                    //Do someThing
                }
            };
            </code>
            </example>
        </member>
        <member name="P:TEC.Core.Net.NetworkShareAccesser.UncPath">
            <summary>
            取得連線的UNC網路路徑
            </summary>
        </member>
        <member name="T:TEC.Core.Net.Resource.ComputerDomain">
            <summary>
              用於查詢當地語系化字串等的強類型資源類別。
            </summary>
        </member>
        <member name="P:TEC.Core.Net.Resource.ComputerDomain.ResourceManager">
            <summary>
              傳回這個類別使用的快取的 ResourceManager 執行個體。
            </summary>
        </member>
        <member name="P:TEC.Core.Net.Resource.ComputerDomain.Culture">
            <summary>
              覆寫目前執行緒的 CurrentUICulture 屬性，對象是所有
              使用這個強類型資源類別的資源查閱。
            </summary>
        </member>
        <member name="P:TEC.Core.Net.Resource.ComputerDomain.GetDomainInfoFailed">
            <summary>
              查詢類似 Cannot get the domain informaion. 的當地語系化字串。
            </summary>
        </member>
        <member name="T:TEC.Core.Runtime.Serialization.ObjectExtension">
            <summary>
            序列化及反序列化物件的衍伸類別
            </summary>
        </member>
        <member name="M:TEC.Core.Runtime.Serialization.ObjectExtension.serializeToBase64String(System.Object)">
            <summary>
            序列化指定的物件，成為Base64String
            </summary>
            <param name="obj">要序列化的物件</param>
            <returns></returns>
        </member>
        <member name="M:TEC.Core.Runtime.Serialization.ObjectExtension.deserializeFromBase64String``1(System.String,System.Action{``0})">
            <summary>
            反序列化Base64String為<typeparamref name="T"/>的物件
            </summary>
            <param name="targetString">要反序列化的文字</param>
            <typeparam name="T">反序列化的目標型態</typeparam>
            <param name="deserializeComplete">當物件反序列畫完成後觸發</param>
            <returns></returns>
        </member>
        <member name="T:TEC.Core.Security.Cryption.AlgorithmName">
            <summary>
            提供對稱式加密演算法的標準
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Cryption.AlgorithmName.DES">
            <summary>
            表示資料加密標準 (Data Encryption Standard，DES) 演算法的基底類別，所有 DES 實作 (Implementation) 必須從它衍生。
            金鑰請使用8個字元的任意值。
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Cryption.AlgorithmName.RC2">
            <summary>
            表示基底類別，RC2 演算法的所有實作 (Implementation) 必須從它衍生。
            金鑰請使用16個字元的任意值。
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Cryption.AlgorithmName.Rijndael">
            <summary>
            表示 Rijndael 對稱加密 (Encryption) 演算法的所有實作 (Implementation) 必須繼承的來源基底類別。
            金鑰請使用16或24個個字元的任意值。
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Cryption.AlgorithmName.TripleDES">
            <summary>
            表示三重資料加密標準 (Triple Data Encryption Standard) 演算法的基底類別，所有 TripleDES 實作 (Implementation) 必須從它衍生。
            金鑰請使用16或24個字元的任意值。
            (預設)
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Cryption.AlgorithmName.AES">
            <summary>
            使用先進加密標準 (AES) 演算法的 Cryptographic Application Programming Interfaces (CAPI) 實作，執行對稱加密和解密。
            </summary>
        </member>
        <member name="T:TEC.Core.Security.Cryption.SymmetricCryption">
            <summary>
            提供多種對稱式的加密方法，這個類別不能被繼承。
            </summary>
            <example>
            <code lang="C#">
            SymmetricCryption symmetricCryption = new SymmetricCryption(AlgorithmName.AES, "TiewpNSBqZM6FUp/r97eCh0bO3/4wjLbhvo+A6U7J4s=", "UgzDzAQZlvRonGSnPN/vPg==", Encoding.Default);
            string encryptedText = symmetricCryption.encrypt("TEC Digital Technology");
            string clearText = symmetricCryption.decrypt(encryptedText);
            </code>
            <remarks>
            <list type="bullet">
               <listheader>
                 <term>注意</term>
               </listheader>
               <item>
                 <term>DES</term>
                 <description>金鑰請使用8字元的任意值，密鑰向量長度應為8</description>
               </item>
               <item>
                 <term>RC2</term>
                 <description>金鑰請使用16字元的任意值，密鑰向量長度應為8</description>
               </item>
               <item>
                 <term>Rijndael</term>
                 <description>金鑰請使用16或24字元的任意值，密鑰向量長度應為16</description>
               </item>
               <item>
                 <term>TripleDES</term>
                 <description>金鑰請使用16或24字元的任意值，密鑰向量長度應為8</description>
               </item>
            </list>
            </remarks>
            </example>
        </member>
        <member name="M:TEC.Core.Security.Cryption.SymmetricCryption.#ctor(TEC.Core.Security.Cryption.AlgorithmName,System.Byte[],System.Byte[],System.Int32)">
            <summary>
            使用系統預設值初始化對稱式加密演算法物件，並使用<see cref="P:System.Text.Encoding.UTF8"/>編碼其內容
            </summary>
            <param name="algorithmName">演算法名稱</param>
            <param name="key">密鑰</param>
            <param name="iv">密鑰向量</param>
            <param name="bufferSize">緩衝區大小，預設1024</param>
        </member>
        <member name="M:TEC.Core.Security.Cryption.SymmetricCryption.#ctor(TEC.Core.Security.Cryption.AlgorithmName,System.Byte[],System.Byte[],System.Text.Encoding,System.Int32)">
            <summary>
            使用系統預設值初始化對稱式加密演算法物件
            </summary>
            <param name="algorithmName">演算法名稱</param>
            <param name="key">密鑰</param>
            <param name="iv">密鑰向量</param>
            <param name="encoding">內容編碼方式</param>
            <param name="bufferSize">緩衝區大小，預設1024</param>
        </member>
        <member name="M:TEC.Core.Security.Cryption.SymmetricCryption.#ctor(TEC.Core.Security.Cryption.AlgorithmName,System.String,System.String,System.Int32)">
            <summary>
            使用系統預設值初始化對稱式加密演算法物件，並使用<see cref="P:System.Text.Encoding.UTF8"/>編碼其內容
            </summary>
            <param name="algorithmName">演算法名稱</param>
            <param name="key">以Base64表示的密鑰</param>
            <param name="iv">以Base64表示的密鑰向量</param>
            <param name="bufferSize">緩衝區大小，預設1024</param>
        </member>
        <member name="M:TEC.Core.Security.Cryption.SymmetricCryption.#ctor(TEC.Core.Security.Cryption.AlgorithmName,System.String,System.String,System.Text.Encoding,System.Int32)">
            <summary>
            使用系統預設值初始化對稱式加密演算法物件
            </summary>
            <param name="algorithmName">演算法名稱</param>
            <param name="key">以Base64表示的密鑰</param>
            <param name="iv">以Base64表示的密鑰向量</param>
            <param name="encoding">內容編碼方式</param>
            <param name="bufferSize">緩衝區大小，預設1024</param>
            <example>
            <code lang="C#">
            SymmetricCryption symmetricCryption = new SymmetricCryption(AlgorithmName.AES, "TiewpNSBqZM6FUp/r97eCh0bO3/4wjLbhvo+A6U7J4s=", "UgzDzAQZlvRonGSnPN/vPg==", Encoding.Default);
            string encryptedText = symmetricCryption.encrypt("TEC Digital Technology");
            string clearText = symmetricCryption.decrypt(encryptedText);
            </code>
            </example>
        </member>
        <member name="M:TEC.Core.Security.Cryption.SymmetricCryption.#ctor(System.Security.Cryptography.SymmetricAlgorithm,System.Text.Encoding,System.Int32)">
            <summary>
            使用指定的對稱式演算法物件初始化物件
            </summary>
            <param name="symmetricAlgorithm">表示抽象基底類別，對稱演算法之所有實作 (Implementation) 必須從它繼承。</param>
            <param name="encoding">內容編碼方式</param>
            <param name="bufferSize">緩衝區大小，預設1024</param>
            <example>
            <code lang="C#">
            AesCryptoServiceProvider aesCryptoServiceProvider = new AesCryptoServiceProvider()
            {
                Mode = CipherMode.CBC,
                Padding = PaddingMode.PKCS7,
                //Key = Convert.FromBase64String("TiewpNSBqZM6FUp/r97eCh0bO3/4wjLbhvo+A6U7J4s="),
                //IV = Convert.FromBase64String("UgzDzAQZlvRonGSnPN/vPg==")
            };
            SymmetricCryption symmetricCryption = new SymmetricCryption(aesCryptoServiceProvider, Encoding.Default);
            string encryptedText = symmetricCryption.encrypt("TEC Digital Technology");
            string clearText = symmetricCryption.decrypt(encryptedText);
            </code>
            </example>
        </member>
        <member name="M:TEC.Core.Security.Cryption.SymmetricCryption.encrypt(System.Byte[])">
            <summary>
            初始化形態的演算法名稱對明文進行加密
            </summary>
            <param name="clearBuffer">明文</param>
            <returns>密文</returns>
        </member>
        <member name="M:TEC.Core.Security.Cryption.SymmetricCryption.encrypt(System.String)">
            <summary>
            初始化形態的演算法名稱對明文進行加密
            </summary>
            <param name="clearText">明文</param>
            <returns>密文</returns>
        </member>
        <member name="M:TEC.Core.Security.Cryption.SymmetricCryption.decrypt(System.Byte[])">
            <summary>
            對已加密的密文進行解碼
            </summary>
            <param name="encryptedBuffer">密文</param>
            <returns>明文</returns>
        </member>
        <member name="M:TEC.Core.Security.Cryption.SymmetricCryption.decrypt(System.String)">
            <summary>
            對已加密的密文進行解碼
            </summary>
            <param name="encryptedText">密文</param>
            <returns>明文</returns>
        </member>
        <member name="M:TEC.Core.Security.Cryption.SymmetricCryption.encryptFile(System.String,System.String)">
            <summary>
            加密檔案
            </summary>
            <param name="sInputFilename">要加密的檔案的完整路徑</param>
            <param name="sOutputFilename">輸出的檔案的的完整路徑</param>
            <example>
            <code lang="C#">
            SymmetricCryption symmetricCryption = new SymmetricCryption(AlgorithmName.AES, "TiewpNSBqZM6FUp/r97eCh0bO3/4wjLbhvo+A6U7J4s=", "UgzDzAQZlvRonGSnPN/vPg==", Encoding.Default);
            symmetricCryption.encryptFile(@"D:\Test.txt", @"D:\Test_Enc.txt");
            symmetricCryption.decryptFile(@"D:\Test_Enc.txt", @"D:\Test_Clear.txt");
            </code>
            </example>
        </member>
        <member name="M:TEC.Core.Security.Cryption.SymmetricCryption.encryptFile(System.Object,System.String)">
            <summary>
             序列化物件以及加密寫入到檔案中
            </summary>
            <param name="sInputObject">要序列化的物件</param>
            <param name="sOutputFilename">要輸出的檔案的完整路徑</param>
            <example>
            <code lang="C#">
            SymmetricCryption symmetricCryption = new SymmetricCryption(AlgorithmName.AES, "TiewpNSBqZM6FUp/r97eCh0bO3/4wjLbhvo+A6U7J4s=", "UgzDzAQZlvRonGSnPN/vPg==", Encoding.Default);
            List&lt;string&gt; stringList = new List&lt;string&gt;() { "TEC", "Digital", "Technology" };
            symmetricCryption.encryptFile(stringList, @"D:\Test_Enc.txt");
            object obj = symmetricCryption.decryptFile(@"D:\Test_Enc.txt");
            </code>
            </example>
        </member>
        <member name="M:TEC.Core.Security.Cryption.SymmetricCryption.decryptFile(System.String,System.String)">
            <summary>
            解密檔案
            </summary>
            <param name="sInputFilename">要解密的檔案的完整路徑</param>
            <param name="sOutputFilename">輸出檔案的完整路徑</param>
            <example>
            <code lang="C#">
            SymmetricCryption symmetricCryption = new SymmetricCryption(AlgorithmName.AES, "TiewpNSBqZM6FUp/r97eCh0bO3/4wjLbhvo+A6U7J4s=", "UgzDzAQZlvRonGSnPN/vPg==", Encoding.Default);
            symmetricCryption.encryptFile(@"D:\Test.txt", @"D:\Test_Enc.txt");
            symmetricCryption.decryptFile(@"D:\Test_Enc.txt", @"D:\Test_Clear.txt");
            </code>
            </example>
        </member>
        <member name="M:TEC.Core.Security.Cryption.SymmetricCryption.decryptFile(System.String)">
            <summary>
            解密檔案以及反序列化物件
            </summary>
            <param name="sInputFilename">加密的序列化檔案完整路徑</param>
            <returns></returns>
            <example>
            <code lang="C#">
            SymmetricCryption symmetricCryption = new SymmetricCryption(AlgorithmName.AES, "TiewpNSBqZM6FUp/r97eCh0bO3/4wjLbhvo+A6U7J4s=", "UgzDzAQZlvRonGSnPN/vPg==", Encoding.Default);
            List&lt;string&gt; stringList = new List&lt;string&gt;() { "TEC", "Digital", "Technology" };
            symmetricCryption.encryptFile(stringList, @"D:\Test_Enc.txt");
            object obj = symmetricCryption.decryptFile(@"D:\Test_Enc.txt");
            </code>
            </example>
        </member>
        <member name="M:TEC.Core.Security.Cryption.SymmetricCryption.Dispose">
            <summary>
            將<see cref="T:TEC.Core.Security.Cryption.SymmetricCryption"/>類別目前的執行個體所使用的資源全部釋出
            </summary>
        </member>
        <member name="M:TEC.Core.Security.Cryption.SymmetricCryption.generateIV(TEC.Core.Security.Cryption.AlgorithmName)">
            <summary>
            隨機產生指定演算法的IV
            </summary>
            <param name="algorithmName">對稱式加密演算法的標準</param>
            <returns>隨機產生的IV</returns>
        </member>
        <member name="M:TEC.Core.Security.Cryption.SymmetricCryption.generateKey(TEC.Core.Security.Cryption.AlgorithmName,System.Nullable{System.Int32})">
            <summary>
            隨機產生指定演算法的Key
            </summary>
            <param name="algorithmName">對稱式加密演算法的標準</param>
            <param name="keySize">對稱演算法使用之秘密金鑰的大小，以位元為單位，若輸入<c lang="C#">null</c>參考則為系統預設</param>
            <returns>隨機產生的Key</returns>
            <exception cref="T:System.Security.Cryptography.CryptographicException">金鑰大小無效。</exception>
        </member>
        <member name="M:TEC.Core.Security.Cryption.SymmetricCryption.generateIVToBase64(TEC.Core.Security.Cryption.AlgorithmName)">
            <summary>
            隨機產生指定演算法的IV，並回傳以Base64字串之表示方式
            </summary>
            <param name="algorithmName">對稱式加密演算法的標準</param>
            <returns>隨機產生的IV(以Base64字串之表示方式)</returns>
        </member>
        <member name="M:TEC.Core.Security.Cryption.SymmetricCryption.generateKeyToBase64(TEC.Core.Security.Cryption.AlgorithmName,System.Nullable{System.Int32})">
            <summary>
            隨機產生指定演算法的Key，並回傳以Base64字串之表示方式
            </summary>
            <param name="algorithmName">對稱式加密演算法的標準</param>
            <param name="keySize">對稱演算法使用之秘密金鑰的大小，以位元為單位，若輸入<c lang="C#">null</c>參考則為系統預設</param>
            <returns>隨機產生的Key(以Base64字串之表示方式)</returns>
            <exception cref="T:System.Security.Cryptography.CryptographicException">金鑰大小無效。</exception>
        </member>
        <member name="P:TEC.Core.Security.Cryption.SymmetricCryption.Encoding">
            <summary>
            取得此對稱式加密的內容編碼方式
            </summary>
        </member>
        <member name="P:TEC.Core.Security.Cryption.SymmetricCryption.SymmetricAlgorithm">
            <summary>
            設定或取得已建立的對稱演算法物件
            </summary>
        </member>
        <member name="P:TEC.Core.Security.Cryption.SymmetricCryption.Encryptor">
            <summary>
            設定或取得加密器
            </summary>
        </member>
        <member name="P:TEC.Core.Security.Cryption.SymmetricCryption.Decryptor">
            <summary>
            設定或取得解密器
            </summary>
        </member>
        <member name="T:TEC.Core.Security.Hash.AlgorithmName">
            <summary>
            雜湊的演算法列舉
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Hash.AlgorithmName.MD5">
            <summary>
            MD5 雜湊演算法
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Hash.AlgorithmName.SHA1">
            <summary>
            SHA1 雜湊演算法
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Hash.AlgorithmName.SHA256">
            <summary>
            SHA256 雜湊演算法
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Hash.AlgorithmName.SHA384">
            <summary>
            SHA384 雜湊演算法
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Hash.AlgorithmName.SHA512">
            <summary>
            SHA512 雜湊演算法
            </summary>
        </member>
        <member name="T:TEC.Core.Security.Hash.HashHelper">
            <summary>
            提供雜湊演算法功能的類別，這個類別不能被繼承。
            </summary>
            <example>
            <code lang="C#">
            HashHelper hashHelper = new HashHelper(AlgorithmName.SHA256, Encoding.Default, 1024);
            string hashString1 = hashHelper.computeHashToBase64("TEC Digital Technology");
            string hashString2 = hashHelper.computeHashToBase64("雲騰科技有限公司");
            </code>
            </example>
        </member>
        <member name="F:TEC.Core.Security.Hash.HashHelper.bufferSize">
            <summary>
            緩衝區大小
            </summary>
        </member>
        <member name="M:TEC.Core.Security.Hash.HashHelper.#ctor(TEC.Core.Security.Hash.AlgorithmName,System.Int32)">
            <summary>
            以系統預設編碼初始化提供雜湊演算法之物件
            </summary>
            <param name="algorithmName">演算法名稱</param>
            <param name="bufferSize">緩衝區大小</param>
        </member>
        <member name="M:TEC.Core.Security.Hash.HashHelper.#ctor(TEC.Core.Security.Hash.AlgorithmName,System.Text.Encoding,System.Int32)">
            <summary>
            初始化提供雜湊演算法之物件
            </summary>
            <param name="algorithmName">演算法名稱</param>
            <param name="encoding">表示用於雜湊明文之字元編碼方式</param>
            <param name="bufferSize">緩衝區大小</param>
        </member>
        <member name="M:TEC.Core.Security.Hash.HashHelper.#ctor(System.Security.Cryptography.HashAlgorithm,System.Int32)">
            <summary>
            以系統預設編碼初始化提供雜湊演算法之物件
            </summary>
            <param name="hashAlgorithm">表示基底類別，密碼編譯雜湊演算法的所有實作 (Implementation) 必須從它衍生。</param>
            <param name="bufferSize">緩衝區大小</param>
        </member>
        <member name="M:TEC.Core.Security.Hash.HashHelper.#ctor(System.Security.Cryptography.HashAlgorithm,System.Text.Encoding,System.Int32)">
            <summary>
            初始化提供雜湊演算法之物件
            </summary>
            <param name="hashAlgorithm">表示基底類別，密碼編譯雜湊演算法的所有實作 (Implementation) 必須從它衍生。</param>
            <param name="encoding">表示用於雜湊明文之字元編碼方式</param>
            <param name="bufferSize">緩衝區大小</param>
        </member>
        <member name="M:TEC.Core.Security.Hash.HashHelper.computeHash(System.String)">
            <summary>
            以設定的雜湊演算法以及編碼方式雜湊指定的字串
            </summary>
            <param name="inputString">用於雜湊的字串</param>
            <returns>計算出來的雜湊程式碼</returns>
        </member>
        <member name="M:TEC.Core.Security.Hash.HashHelper.computeHashToBase64(System.String)">
            <summary>
            以設定的雜湊演算法以及編碼方式雜湊指定的字串
            </summary>
            <param name="inputString">用於雜湊的字串</param>
            <returns>計算出來的雜湊程式碼(Base64)</returns>
            <example>
            <code lang="C#">
            HashHelper hashHelper = new HashHelper(AlgorithmName.SHA256, Encoding.Default, 1024);
            string hashString1 = hashHelper.computeHashToBase64("TEC Digital Technology");
            string hashString2 = hashHelper.computeHashToBase64("雲騰科技有限公司");
            </code>
            </example>
        </member>
        <member name="M:TEC.Core.Security.Hash.HashHelper.Dispose">
            <summary>
            將<see cref="T:TEC.Core.Security.Hash.HashHelper"/>類別目前的執行個體所使用的資源全部釋出
            </summary>
        </member>
        <member name="P:TEC.Core.Security.Hash.HashHelper.HashAlgorithm">
            <summary>
            設定或取得密碼編譯雜湊演算法的物件
            </summary>
        </member>
        <member name="P:TEC.Core.Security.Hash.HashHelper.Encoding">
            <summary>
            取得用於雜湊明文之字元編碼方式
            </summary>
        </member>
        <member name="T:TEC.Core.Security.Logon.AuthenticationPrompt">
            <summary>
            利用Windows內建的UI來提示使用者輸入密碼
            </summary>
        </member>
        <member name="M:TEC.Core.Security.Logon.AuthenticationPrompt.CredUIPromptForCredentials(TEC.Core.Security.Logon.CREDUI_INFO@,System.String,System.IntPtr,System.Int32,System.Text.StringBuilder,System.Int32,System.Text.StringBuilder,System.Int32,System.Boolean@,TEC.Core.Security.Logon.CREDUI_FLAGS)">
             <summary>
             本方法將建立以及顯示讓使用者可以輸入認證資訊的視窗，若系統為Vista或Windows Server 2008以上，請改用
             <see cref="M:TEC.Core.Security.Logon.AuthenticationPrompt.CredUIPromptForWindowsCredentials(TEC.Core.Security.Logon.CREDUI_INFO@,System.Int32,System.UInt32@,System.IntPtr,System.UInt32,System.IntPtr@,System.UInt32@,System.Boolean@,TEC.Core.Security.Logon.CREDUIWIN)"/>
             </summary>
             <param name="pUiInfo">輸入自訂認證視窗的參數</param>
             <param name="pszTargetName">包含要認證目標的資訊，通常是ServerName，對於分散式檔案系統而言，
             應該會輸入ServerName\ShareName格式的字串。這個參數也用於認證管理員的識別資訊。</param>
             <param name="reserved">這個值為保留值，以便未來擴充用，目前值必須填入<c lang="C#">IntPtr.Zero</c></param>
             <param name="dwAuthError">定義需要認證視窗的原因，可以輸入關於視窗錯誤的參數，
             如果要取得關於最近一次所發生的Unmanaged錯誤，可以使用<c lang="C#">Marshal.GetLastWin32Error();</c>來取得，
             其他錯誤碼的詳細資訊請參考 http://msdn.microsoft.com/en-us/library/windows/desktop/ms681382(v=vs.85).aspx </param>
             <param name="pszUserName">使用者名稱，如果輸入的參數長度不為0，則認證訊息視窗的使用者名稱就會預先填入該參數作為前置字串</param>
             <param name="ulUserNameMaxChars">在pszUserName參數允許的最大值</param>
             <param name="pszPassword">密碼，如果輸入的參數長度不為0，則認證訊息視窗的密碼就會預先填入該參數作為前置字串</param>
             <param name="ulPasswordMaxChars">在pszPassword參數允許的最大值</param>
             <param name="pfSave">
             當flags參數的值有設定<see cref="F:TEC.Core.Security.Logon.CREDUI_FLAGS.PERSIST"/>時，雖然"儲存密碼"的方塊不會顯示，
             但是還是會依照輸入的值來決定是否要儲存密碼；<see cref="F:TEC.Core.Security.Logon.CREDUI_FLAGS.DO_NOT_PERSIST"/>時，
             既不會顯示"儲存密碼"的方塊，也預設為不儲存認證，則本參數的值會被忽略</param>
             <param name="flags">客製化選項</param>
             <returns>執行結果的狀態</returns>
             <example>
             <para>AuthenticatioinPromptTest.cs</para>
             <code lang="C#">
             using System;
             using System.Collections.Generic;
             using System.Linq;
             using System.Net;
             using System.Runtime.InteropServices;
             using System.Security.Principal;
             using System.Text;
             using System.Text.RegularExpressions;
             using System.Threading.Tasks;
             using TEC.Core.Security.Logon;
             namespace TEC.Core.TestConsole.Security.Logon
                 {
                     public class AuthenticationPromptTest
                     {
                         public static void main()
                         {
                             CREDUI_INFO credui = new CREDUI_INFO();
                             credui.cbSize = Marshal.SizeOf(credui);
                             credui.pszCaptionText = String.Format("請輸入用於登入{0}的認證", " localhost ");
                             credui.pszMessageText = "登入";
                             string account, domain, password;
                             int lastError = 0;//第一次顯示視窗是正常的，因為沒有任何錯誤
                             do
                             {
                                 lastError = Marshal.GetLastWin32Error();
                                 NetworkCredential credential;
                                 CredUIReturnCodes returnCode;
                                 //若系統"為"Vista或Windows Server 2008以上，請使用下列方法
                                 AuthenticationPromptTest.promptUserForWindowsCredentials(credui, lastError, out credential, out returnCode);
                                 //若系統"非"Vista或Windows Server 2008以上，請使用下列方法
                                 //AuthenticationPromptTest.promptUserForCredentials(credui, "tpe.tecyt.com", lastError, out credential, out returnCode);
                                 if (returnCode == CredUIReturnCodes.ERROR_CANCELLED)
                                 {
                                     //使用者按下取消
                                     return;
                                 }
                                 Regex accountFilterExpression = new Regex(@"((.)+\\)|(@(.)+)", RegexOptions.Singleline);
                                 Regex domainFilterExpression = new Regex(@"(\\.+)|((.)+@)", RegexOptions.Singleline);
                                 account = accountFilterExpression.Replace(credential.UserName, "");
                                 domain = domainFilterExpression.IsMatch(credential.UserName) ? domainFilterExpression.Replace(credential.UserName, "") : Environment.UserDomainName;
                                 password = credential.Password;
                             }
                             while (!AuthenticationPromptTest.impersonateValidUser(account, domain, password));
                             //登入成功，以指定身分執行程式碼(目前執行緒)
                             //....
                             //....
                             //....
                             //還原身分(登出已模擬的使用者)
                             WindowsImpersonation.undoImpersonationUser();
                         }
                         /// &lt;summary&gt;
                         /// 模擬其他使用者的登入
                         /// &lt;/summary&gt;
                         /// &lt;param name="userName"&gt;使用者帳號&lt;/param&gt;
                         /// &lt;param name="domain"&gt;網域&lt;/param&gt;
                         /// &lt;param name="password"&gt;密碼&lt;/param&gt;
                         /// &lt;returns&gt;是否驗證成功以及登入完成&lt;/returns&gt;
                         public static bool impersonateValidUser(string userName, string domain, string password)
                         {
                             WindowsImpersonation.undoImpersonationUser();//先還原
                             string originalUserName = WindowsIdentity.GetCurrent().Name;//原始的登入
                             if (WindowsImpersonation.impersonateValidUser(userName, domain, password, LogonType.LOGON32_LOGON_INTERACTIVE, LogonProvider.LOGON32_PROVIDER_DEFAULT))
                             {
                                 //模擬的登入，要比對跟原有的是否一樣
                                 if (originalUserName.Equals(WindowsIdentity.GetCurrent().Name))
                                 {
                                     //是原有使用者，無須模擬
                                     WindowsImpersonation.undoImpersonationUser();
                                 }
            
                                 return true;
                             }
                             else
                             {
                                 return false;
                             }
                         }
                         /// &lt;summary&gt;
                         /// 提示使用者輸入相關帳號密碼資訊，並傳回其認證
                         /// &lt;/summary&gt;
                         /// &lt;param name="credui"&gt;自訂視窗&lt;/param&gt;
                         /// &lt;param name="dwAuthError"&gt;相關的錯誤資訊，若不顯示，則輸入0，詳細資訊請參考 http://msdn.microsoft.com/en-us/library/windows/desktop/ms681382(v=vs.85).aspx &lt;/param&gt;
                         /// &lt;param name="networkCredential"&gt;取得的認證結果，若取得失敗或被取消，會傳回null&lt;/param&gt;
                         /// &lt;param name="returnCode"&gt;呼叫結果&lt;/param&gt;
                         public static void promptUserForWindowsCredentials(CREDUI_INFO credui, int dwAuthError, out System.Net.NetworkCredential networkCredential, out CredUIReturnCodes returnCode)
                         {
                             uint authPackage = 0;
                             IntPtr outCredBuffer;
                             uint outCredSize;
                             bool save = false;
                             returnCode = AuthenticationPrompt.CredUIPromptForWindowsCredentials(ref credui,
                                                                            dwAuthError, //輸入錯誤碼以顯示於UI
                                                                            ref authPackage,
                                                                            IntPtr.Zero,
                                                                            0,
                                                                            out outCredBuffer,
                                                                            out outCredSize,
                                                                            ref save,
                                                                            CREDUIWIN.AUTHPACKAGE_ONLY);
             
                             StringBuilder usernameBuf = new StringBuilder(100);
                             StringBuilder passwordBuf = new StringBuilder(100);
                             StringBuilder domainBuf = new StringBuilder(100);
             
                             int maxUserName = 100;
                             int maxDomain = 100;
                             int maxPassword = 100;
                             if (returnCode == CredUIReturnCodes.NO_ERROR)
                             {
                                 if (AuthenticationPrompt.CredUnPackAuthenticationBuffer(0, outCredBuffer, outCredSize, usernameBuf, ref maxUserName,
                                                                    domainBuf, ref maxDomain, passwordBuf, ref maxPassword))
                                 {
                                     //清除被CredUIPromptForWindowsCredentials所占用的記憶體
                                     AuthenticationPrompt.CoTaskMemFree(outCredBuffer);
                                     System.Security.SecureString securePassword = new System.Security.SecureString();
                                     for (int i = 0; i &lt; passwordBuf.Length; i++)
                                     {
                                         securePassword.AppendChar(passwordBuf[i]);
                                     }
                                     networkCredential = new System.Net.NetworkCredential()
                                     {
                                         UserName = usernameBuf.ToString(),
                                         Password = passwordBuf.ToString(),
                                         Domain = domainBuf.ToString(),
                                         SecurePassword = securePassword
                                     };
                                     //取得帳密資訊完成
                                     return;
                                 }
                             }
                             //其中有些地方有出錯
                             networkCredential = null;
                         }
                         /// &lt;summary&gt;
                         /// 提示使用者輸入相關帳號密碼資訊，並傳回其認證
                         /// &lt;/summary&gt;
                         /// &lt;param name="credui"&gt;自訂視窗&lt;/param&gt;
                         /// &lt;param name="dwAuthError"&gt;相關的錯誤資訊，若不顯示，則輸入0，詳細資訊請參考 http://msdn.microsoft.com/en-us/library/windows/desktop/ms681382(v=vs.85).aspx &lt;/param&gt;
                         /// &lt;param name="networkCredential"&gt;取得的認證結果，若取得失敗或被取消，會傳回null&lt;/param&gt;
                         /// &lt;param name="serverName"&gt;包含要認證目標的資訊，通常是ServerName，對於分散式檔案系統而言， 應該會輸入ServerName\ShareName格式的字串。這個參數也用於認證管理員的識別資訊。&lt;/param&gt;
                         /// &lt;param name="returnCode"&gt;呼叫結果&lt;/param&gt;
                         public static void promptUserForCredentials(CREDUI_INFO credui, string serverName, int dwAuthError, out System.Net.NetworkCredential networkCredential, out CredUIReturnCodes returnCode)
                         {
                             StringBuilder userPassword = new StringBuilder(), userID = new StringBuilder();
                             // 設定相關變數
                             CREDUI_INFO credUI = new CREDUI_INFO();
                             credUI.cbSize = Marshal.SizeOf(credUI);
                             bool save = false;
                             CREDUI_FLAGS flags = CREDUI_FLAGS.ALWAYS_SHOW_UI | CREDUI_FLAGS.GENERIC_CREDENTIALS | CREDUI_FLAGS.SHOW_SAVE_CHECK_BOX;
                             // 顯示視窗
                             returnCode = AuthenticationPrompt.CredUIPromptForCredentials(
                                ref credUI,
                                serverName,
                                IntPtr.Zero,
                                dwAuthError, //輸入錯誤碼以顯示於UI
                                userID,
                                100,
                                userPassword,
                                100,
                                ref save,
                                flags);
                             if (returnCode == CredUIReturnCodes.NO_ERROR)
                             {
                                 System.Security.SecureString securePassword = new System.Security.SecureString();
                                 for (int i = 0; i &lt; userPassword.Length; i++)
                                 {
                                     securePassword.AppendChar(userPassword[i]);
                                 }
                                 //沒有任何錯誤發生
                                 networkCredential = new System.Net.NetworkCredential()
                                 {
                                     UserName = userID.ToString(),
                                     Password = userPassword.ToString(),
                                     SecurePassword = securePassword,
                                     Domain = serverName
                                 };
                                 //取得帳密資訊完成
                                 return;
                             }
                             networkCredential = null;
                         }
                     }
                 }
             </code>
             </example>
             <remarks>
             <para>關於詳細原文說明，請參考 http://msdn.microsoft.com/zh-tw/library/aa375177.aspx </para>
             <para>要搭配Windows登入，請參考<see cref="T:TEC.Core.Security.Logon.WindowsImpersonation"/></para>
             </remarks>
             <seealso cref="T:TEC.Core.Security.Logon.WindowsImpersonation"/>
             <seealso cref="M:TEC.Core.Security.Logon.AuthenticationPrompt.CredUnPackAuthenticationBuffer(System.Int32,System.IntPtr,System.UInt32,System.Text.StringBuilder,System.Int32@,System.Text.StringBuilder,System.Int32@,System.Text.StringBuilder,System.Int32@)"/>
        </member>
        <member name="M:TEC.Core.Security.Logon.AuthenticationPrompt.CredUIPromptForWindowsCredentials(TEC.Core.Security.Logon.CREDUI_INFO@,System.Int32,System.UInt32@,System.IntPtr,System.UInt32,System.IntPtr@,System.UInt32@,System.Boolean@,TEC.Core.Security.Logon.CREDUIWIN)">
             <summary>
             本方法將建立以及顯示讓使用者可以透過本機電腦已安裝的認證提供者來輸入認證資訊的視窗
             </summary>
             <param name="pUiInfo">
             自訂認證視窗的UI。
             如果<see cref="F:TEC.Core.Security.Logon.CREDUI_INFO.hwndParent"/>為<c lang="C#">IntPtr.Zero</c>，
             則視窗將出現於螢幕正中間，如果<see cref="F:TEC.Core.Security.Logon.CREDUI_INFO.hwndParent"/>不為<c lang="C#">IntPtr.Zero</c>，
             則視窗將出現於父視窗的中間。
             </param>
             <param name="dwAuthError">定義於Winerror.h的Windows錯誤代碼，這會顯示在認證視窗中。如果先前的認證未通過，
             則呼叫端應該使用這個參數來將先前發生的錯誤訊息(例:Winlogon)傳遞到此方法中(如:<c lang="C#">Marshal.GetLastWin32Error();</c>)，相對應的訊息會呈現於認證視窗中，
             如果不顯示任何錯誤訊息，請輸入0，詳細資訊請參考 http://msdn.microsoft.com/en-us/library/windows/desktop/ms681382(v=vs.85).aspx </param>
             <param name="authPackage">這個參數的值將會用於認證套件，該認證是被序列化存放於InAuthBuffer的參數中，相關的資訊請參考 http://msdn.microsoft.com/zh-tw/library/aa378297.aspx </param>
             <param name="pvInAuthBuffer">將BLOB認證(Credential BLOB)填入到認證視窗中，如果要保留空白，應填入<c lang="C#">InPtr.Zero</c></param>
             <param name="ulInAuthBufferSize">pvInAuthBuffer的大小，單位為byte</param>
             <param name="ppvOutAuthBuffer">BLOB認證(Credential BLOB)的位址。對於Kerberos、NTLM或Negotiate認證，必須呼叫CredUnPackAuthenticationBuffer將BLOB轉換成字串形式的認證資訊</param>
             <param name="pulOutAuthBufferSize">ppvOutAuthBuffer的大小，單位為byte</param>
             <param name="fSave">對於輸入而言，用於決定"儲存認證"是否被核取；對於輸出而言，用於取得認證資訊視窗的"儲存認證"是否被核取。
             如果dwFlags的參數沒有設定<see cref="F:TEC.Core.Security.Logon.CREDUIWIN.CHECKBOX"/>，將會略過這個值</param>
             <param name="dwFlags">相關的設定，可以用 or 來設定一個或多個值</param>
             <returns></returns>
             <remarks>
             <para>關於詳細原文說明，請參考 http://msdn.microsoft.com/zh-tw/library/aa375177.aspx </para>
             <para>要搭配Windows登入，請參考<see cref="T:TEC.Core.Security.Logon.WindowsImpersonation"/></para>
             </remarks>
             <example>
             <para>AuthenticatioinPromptTest.cs</para>
             <code lang="C#">
             using System;
             using System.Collections.Generic;
             using System.Linq;
             using System.Net;
             using System.Runtime.InteropServices;
             using System.Security.Principal;
             using System.Text;
             using System.Text.RegularExpressions;
             using System.Threading.Tasks;
             using TEC.Core.Security.Logon;
             namespace TEC.Core.TestConsole.Security.Logon
                 {
                     public class AuthenticationPromptTest
                     {
                         public static void main()
                         {
                             CREDUI_INFO credui = new CREDUI_INFO();
                             credui.cbSize = Marshal.SizeOf(credui);
                             credui.pszCaptionText = String.Format("請輸入用於登入{0}的認證", " localhost ");
                             credui.pszMessageText = "登入";
                             string account, domain, password;
                             int lastError = 0;//第一次顯示視窗是正常的，因為沒有任何錯誤
                             do
                             {
                                 lastError = Marshal.GetLastWin32Error();
                                 NetworkCredential credential;
                                 CredUIReturnCodes returnCode;
                                 //若系統"為"Vista或Windows Server 2008以上，請使用下列方法
                                 AuthenticationPromptTest.promptUserForWindowsCredentials(credui, lastError, out credential, out returnCode);
                                 //若系統"非"Vista或Windows Server 2008以上，請使用下列方法
                                 //AuthenticationPromptTest.promptUserForCredentials(credui, "tpe.tecyt.com", lastError, out credential, out returnCode);
                                 if (returnCode == CredUIReturnCodes.ERROR_CANCELLED)
                                 {
                                     //使用者按下取消
                                     return;
                                 }
                                 Regex accountFilterExpression = new Regex(@"((.)+\\)|(@(.)+)", RegexOptions.Singleline);
                                 Regex domainFilterExpression = new Regex(@"(\\.+)|((.)+@)", RegexOptions.Singleline);
                                 account = accountFilterExpression.Replace(credential.UserName, "");
                                 domain = domainFilterExpression.IsMatch(credential.UserName) ? domainFilterExpression.Replace(credential.UserName, "") : Environment.UserDomainName;
                                 password = credential.Password;
                             }
                             while (!AuthenticationPromptTest.impersonateValidUser(account, domain, password));
                             //登入成功，以指定身分執行程式碼(目前執行緒)
                             //....
                             //....
                             //....
                             //還原身分(登出已模擬的使用者)
                             WindowsImpersonation.undoImpersonationUser();
                         }
                         /// &lt;summary&gt;
                         /// 模擬其他使用者的登入
                         /// &lt;/summary&gt;
                         /// &lt;param name="userName"&gt;使用者帳號&lt;/param&gt;
                         /// &lt;param name="domain"&gt;網域&lt;/param&gt;
                         /// &lt;param name="password"&gt;密碼&lt;/param&gt;
                         /// &lt;returns&gt;是否驗證成功以及登入完成&lt;/returns&gt;
                         public static bool impersonateValidUser(string userName, string domain, string password)
                         {
                             WindowsImpersonation.undoImpersonationUser();//先還原
                             string originalUserName = WindowsIdentity.GetCurrent().Name;//原始的登入
                             if (WindowsImpersonation.impersonateValidUser(userName, domain, password, LogonType.LOGON32_LOGON_INTERACTIVE, LogonProvider.LOGON32_PROVIDER_DEFAULT))
                             {
                                 //模擬的登入，要比對跟原有的是否一樣
                                 if (originalUserName.Equals(WindowsIdentity.GetCurrent().Name))
                                 {
                                     //是原有使用者，無須模擬
                                     WindowsImpersonation.undoImpersonationUser();
                                 }
            
                                 return true;
                             }
                             else
                             {
                                 return false;
                             }
                         }
                         /// &lt;summary&gt;
                         /// 提示使用者輸入相關帳號密碼資訊，並傳回其認證
                         /// &lt;/summary&gt;
                         /// &lt;param name="credui"&gt;自訂視窗&lt;/param&gt;
                         /// &lt;param name="dwAuthError"&gt;相關的錯誤資訊，若不顯示，則輸入0，詳細資訊請參考 http://msdn.microsoft.com/en-us/library/windows/desktop/ms681382(v=vs.85).aspx &lt;/param&gt;
                         /// &lt;param name="networkCredential"&gt;取得的認證結果，若取得失敗或被取消，會傳回null&lt;/param&gt;
                         /// &lt;param name="returnCode"&gt;呼叫結果&lt;/param&gt;
                         public static void promptUserForWindowsCredentials(CREDUI_INFO credui, int dwAuthError, out System.Net.NetworkCredential networkCredential, out CredUIReturnCodes returnCode)
                         {
                             uint authPackage = 0;
                             IntPtr outCredBuffer;
                             uint outCredSize;
                             bool save = false;
                             returnCode = AuthenticationPrompt.CredUIPromptForWindowsCredentials(ref credui,
                                                                            dwAuthError, //輸入錯誤碼以顯示於UI
                                                                            ref authPackage,
                                                                            IntPtr.Zero,
                                                                            0,
                                                                            out outCredBuffer,
                                                                            out outCredSize,
                                                                            ref save,
                                                                            CREDUIWIN.AUTHPACKAGE_ONLY);
             
                             StringBuilder usernameBuf = new StringBuilder(100);
                             StringBuilder passwordBuf = new StringBuilder(100);
                             StringBuilder domainBuf = new StringBuilder(100);
             
                             int maxUserName = 100;
                             int maxDomain = 100;
                             int maxPassword = 100;
                             if (returnCode == CredUIReturnCodes.NO_ERROR)
                             {
                                 if (AuthenticationPrompt.CredUnPackAuthenticationBuffer(0, outCredBuffer, outCredSize, usernameBuf, ref maxUserName,
                                                                    domainBuf, ref maxDomain, passwordBuf, ref maxPassword))
                                 {
                                     //清除被CredUIPromptForWindowsCredentials所占用的記憶體
                                     AuthenticationPrompt.CoTaskMemFree(outCredBuffer);
                                     System.Security.SecureString securePassword = new System.Security.SecureString();
                                     for (int i = 0; i &lt; passwordBuf.Length; i++)
                                     {
                                         securePassword.AppendChar(passwordBuf[i]);
                                     }
                                     networkCredential = new System.Net.NetworkCredential()
                                     {
                                         UserName = usernameBuf.ToString(),
                                         Password = passwordBuf.ToString(),
                                         Domain = domainBuf.ToString(),
                                         SecurePassword = securePassword
                                     };
                                     //取得帳密資訊完成
                                     return;
                                 }
                             }
                             //其中有些地方有出錯
                             networkCredential = null;
                         }
                         /// &lt;summary&gt;
                         /// 提示使用者輸入相關帳號密碼資訊，並傳回其認證
                         /// &lt;/summary&gt;
                         /// &lt;param name="credui"&gt;自訂視窗&lt;/param&gt;
                         /// &lt;param name="dwAuthError"&gt;相關的錯誤資訊，若不顯示，則輸入0，詳細資訊請參考 http://msdn.microsoft.com/en-us/library/windows/desktop/ms681382(v=vs.85).aspx &lt;/param&gt;
                         /// &lt;param name="networkCredential"&gt;取得的認證結果，若取得失敗或被取消，會傳回null&lt;/param&gt;
                         /// &lt;param name="serverName"&gt;包含要認證目標的資訊，通常是ServerName，對於分散式檔案系統而言， 應該會輸入ServerName\ShareName格式的字串。這個參數也用於認證管理員的識別資訊。&lt;/param&gt;
                         /// &lt;param name="returnCode"&gt;呼叫結果&lt;/param&gt;
                         public static void promptUserForCredentials(CREDUI_INFO credui, string serverName, int dwAuthError, out System.Net.NetworkCredential networkCredential, out CredUIReturnCodes returnCode)
                         {
                             StringBuilder userPassword = new StringBuilder(), userID = new StringBuilder();
                             // 設定相關變數
                             CREDUI_INFO credUI = new CREDUI_INFO();
                             credUI.cbSize = Marshal.SizeOf(credUI);
                             bool save = false;
                             CREDUI_FLAGS flags = CREDUI_FLAGS.ALWAYS_SHOW_UI | CREDUI_FLAGS.GENERIC_CREDENTIALS | CREDUI_FLAGS.SHOW_SAVE_CHECK_BOX;
                             // 顯示視窗
                             returnCode = AuthenticationPrompt.CredUIPromptForCredentials(
                                ref credUI,
                                serverName,
                                IntPtr.Zero,
                                dwAuthError, //輸入錯誤碼以顯示於UI
                                userID,
                                100,
                                userPassword,
                                100,
                                ref save,
                                flags);
                             if (returnCode == CredUIReturnCodes.NO_ERROR)
                             {
                                 System.Security.SecureString securePassword = new System.Security.SecureString();
                                 for (int i = 0; i &lt; userPassword.Length; i++)
                                 {
                                     securePassword.AppendChar(userPassword[i]);
                                 }
                                 //沒有任何錯誤發生
                                 networkCredential = new System.Net.NetworkCredential()
                                 {
                                     UserName = userID.ToString(),
                                     Password = userPassword.ToString(),
                                     SecurePassword = securePassword,
                                     Domain = serverName
                                 };
                                 //取得帳密資訊完成
                                 return;
                             }
                             networkCredential = null;
                         }
                     }
                 }
             </code>
             </example>
             <seealso cref="M:TEC.Core.Security.Logon.AuthenticationPrompt.CredUnPackAuthenticationBuffer(System.Int32,System.IntPtr,System.UInt32,System.Text.StringBuilder,System.Int32@,System.Text.StringBuilder,System.Int32@,System.Text.StringBuilder,System.Int32@)"/>
             <seealso cref="T:TEC.Core.Security.Logon.WindowsImpersonation"/>
        </member>
        <member name="M:TEC.Core.Security.Logon.AuthenticationPrompt.CredUnPackAuthenticationBuffer(System.Int32,System.IntPtr,System.UInt32,System.Text.StringBuilder,System.Int32@,System.Text.StringBuilder,System.Int32@,System.Text.StringBuilder,System.Int32@)">
            <summary>
            轉換由呼叫<see cref="M:TEC.Core.Security.Logon.AuthenticationPrompt.CredUIPromptForWindowsCredentials(TEC.Core.Security.Logon.CREDUI_INFO@,System.Int32,System.UInt32@,System.IntPtr,System.UInt32,System.IntPtr@,System.UInt32@,System.Boolean@,TEC.Core.Security.Logon.CREDUIWIN)"/>
            後傳回的ppvOutAuthBuffer為使用者名稱以及密碼
            </summary>
            <param name="dwFlags">
            設定本參數來決定於認證緩衝區(authentication buffer)的解密方式，如果無法順利解密，本方法將傳回false。
            要如何輸入解密方式取決於認證緩衝區(authentication buffer)的格式。
            </param>
            <param name="pAuthBuffer">
            這個值應該由呼叫<see cref="M:TEC.Core.Security.Logon.AuthenticationPrompt.CredUIPromptForWindowsCredentials(TEC.Core.Security.Logon.CREDUI_INFO@,System.Int32,System.UInt32@,System.IntPtr,System.UInt32,System.IntPtr@,System.UInt32@,System.Boolean@,TEC.Core.Security.Logon.CREDUIWIN)"/>或
            CredPackAuthenticationBuffer來得到。
            </param>
            <param name="cbAuthBuffer">pAuthBuffer參數的大小，單位為bytes</param>
            <param name="pszUserName">使用者名稱</param>
            <param name="pcchMaxUserName">pszUserName的字串大小。
            對於輸出時，如果輸出大小超過緩衝區大小，請指定其值，這個值也包含表示null的字元</param>
            <param name="pszDomainName">表示使用者的網域</param>
            <param name="pcchMaxDomainame">pszDomainName的字串大小。
            對於輸出時，如果輸出大小超過緩衝區大小，請指定其值。如果沒有網域名稱，也可以設定為0</param>
            <param name="pszPassword">密碼</param>
            <param name="pcchMaxPassword">pszPassword的字串大小。
            對於輸出時，如果輸出大小超過緩衝區大小，請指定其值，這個值也包含表示null的字元</param>
            <returns>是否成功解密資料</returns>
            <remarks>
            詳細資訊請參考 http://msdn.microsoft.com/zh-tw/library/aa375185.aspx
            </remarks>
            <seealso cref="M:TEC.Core.Security.Logon.AuthenticationPrompt.CredUIPromptForWindowsCredentials(TEC.Core.Security.Logon.CREDUI_INFO@,System.Int32,System.UInt32@,System.IntPtr,System.UInt32,System.IntPtr@,System.UInt32@,System.Boolean@,TEC.Core.Security.Logon.CREDUIWIN)"/>
        </member>
        <member name="M:TEC.Core.Security.Logon.AuthenticationPrompt.CoTaskMemFree(System.IntPtr)">
            <summary>
            清除被鎖定的記憶體
            </summary>
            <param name="ptr">相關的指標</param>
        </member>
        <member name="T:TEC.Core.Security.Logon.CredUIReturnCodes">
            <summary>
            當呼叫<see cref="M:TEC.Core.Security.Logon.AuthenticationPrompt.CredUIPromptForCredentials(TEC.Core.Security.Logon.CREDUI_INFO@,System.String,System.IntPtr,System.Int32,System.Text.StringBuilder,System.Int32,System.Text.StringBuilder,System.Int32,System.Boolean@,TEC.Core.Security.Logon.CREDUI_FLAGS)"/>所傳回的值
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CredUIReturnCodes.NO_ERROR">
            <summary>
            使用者選擇OK，並且傳回pszUserName、pszPassword、以及pfSave這三個參數
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CredUIReturnCodes.ERROR_CANCELLED">
            <summary>
            使用者選擇Cancel，並且pszUserName及pszPassword參數皆不會被改變 
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CredUIReturnCodes.ERROR_NO_SUCH_LOGON_SESSION">
            <summary>
            認證管理員無法使用，這個錯誤會當CredUIPromptForCredentials被呼叫時且同時使用
            <see cref="F:TEC.Core.Security.Logon.CREDUI_FLAGS.DO_NOT_PERSIST"/>參數
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CredUIReturnCodes.ERROR_NOT_FOUND">
            <summary>
            未知的錯誤
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CredUIReturnCodes.ERROR_INVALID_ACCOUNT_NAME">
            <summary>
            帳號錯誤
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CredUIReturnCodes.ERROR_INSUFFICIENT_BUFFER">
            <summary>
            緩衝區不足
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CredUIReturnCodes.ERROR_INVALID_PARAMETER">
            <summary>
            任何參數的錯誤會都傳回這個值，若要檢查，請注意下列幾點:
            1.必須指定<see cref="F:TEC.Core.Security.Logon.CREDUI_INFO.cbSize"/>
            2.如果<see cref="F:TEC.Core.Security.Logon.CREDUI_INFO.hbmBanner"/>不為null，則該參數型別必為Bitmap
            3.如果<see cref="F:TEC.Core.Security.Logon.CREDUI_INFO.pszMessageText"/>不為null，則不能輸入過長文字
            3.如果<see cref="F:TEC.Core.Security.Logon.CREDUI_INFO.pszCaptionText"/>不為null，則不能輸入過長文字
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CredUIReturnCodes.ERROR_INVALID_FLAGS">
            <summary>
            <see cref="T:TEC.Core.Security.Logon.CREDUI_INFO"/>有衝突或錯誤
            </summary>
        </member>
        <member name="T:TEC.Core.Security.Logon.CREDUIWIN">
            <summary>
            用於<see cref="M:TEC.Core.Security.Logon.AuthenticationPrompt.CredUIPromptForWindowsCredentials(TEC.Core.Security.Logon.CREDUI_INFO@,System.Int32,System.UInt32@,System.IntPtr,System.UInt32,System.IntPtr@,System.UInt32@,System.Boolean@,TEC.Core.Security.Logon.CREDUIWIN)"/>方法的列舉
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUIWIN.GENERIC">
            <summary>
            認證管理員必須以純文字傳回使用者名稱以及密碼，這個值不能與
            <see cref="F:TEC.Core.Security.Logon.CREDUIWIN.SECURE_PROMPT"/>同時設定
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUIWIN.CHECKBOX">
            <summary>
            顯示"儲存認證"於認證提示視窗中
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUIWIN.AUTHPACKAGE_ONLY">
            <summary>
            只有支援<see cref="M:TEC.Core.Security.Logon.AuthenticationPrompt.CredUIPromptForWindowsCredentials(TEC.Core.Security.Logon.CREDUI_INFO@,System.Int32,System.UInt32@,System.IntPtr,System.UInt32,System.IntPtr@,System.UInt32@,System.Boolean@,TEC.Core.Security.Logon.CREDUIWIN)"/>中
            authPackage參數的認證套件的認證提供者會被列舉出來，這個值不能與
            <see cref="F:TEC.Core.Security.Logon.CREDUIWIN.IN_CRED_ONLY"/>同時設定
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUIWIN.IN_CRED_ONLY">
            <summary>
            只有從<see cref="M:TEC.Core.Security.Logon.AuthenticationPrompt.CredUIPromptForWindowsCredentials(TEC.Core.Security.Logon.CREDUI_INFO@,System.Int32,System.UInt32@,System.IntPtr,System.UInt32,System.IntPtr@,System.UInt32@,System.Boolean@,TEC.Core.Security.Logon.CREDUIWIN)"/>中
            pulAuthPackage認證套件中所定義的認證會被列舉出來，這個值不能與
            <see cref="F:TEC.Core.Security.Logon.CREDUIWIN.AUTHPACKAGE_ONLY"/>同時設定
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUIWIN.ENUMERATE_ADMINS">
            <summary>
            認證提供者只列舉Administrators。這個值應改只用於User Account Control(UAC)目的之用，外部呼叫不建議設定這個值
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUIWIN.ENUMERATE_CURRENT_USER">
            <summary>
            只有在<see cref="M:TEC.Core.Security.Logon.AuthenticationPrompt.CredUIPromptForWindowsCredentials(TEC.Core.Security.Logon.CREDUI_INFO@,System.Int32,System.UInt32@,System.IntPtr,System.UInt32,System.IntPtr@,System.UInt32@,System.Boolean@,TEC.Core.Security.Logon.CREDUIWIN)"/>中
            pulAuthPackage所輸入的認證會被列舉出來
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUIWIN.SECURE_PROMPT">
            <summary>
            認證視窗只會出現在安全桌面，這個值不能與
            <see cref="F:TEC.Core.Security.Logon.CREDUIWIN.GENERIC"/>同時設定
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUIWIN.PREPROMPTING">
            <summary>
            認證視窗被SspiPromptForCredentials方法所驅動，且在出現之前，會先與客戶端交握。
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUIWIN.PACK_32_WOW">
            <summary>
            不論系統是否正以64位元執行，
            認證提供者應與<see cref="M:TEC.Core.Security.Logon.AuthenticationPrompt.CredUIPromptForWindowsCredentials(TEC.Core.Security.Logon.CREDUI_INFO@,System.Int32,System.UInt32@,System.IntPtr,System.UInt32,System.IntPtr@,System.UInt32@,System.Boolean@,TEC.Core.Security.Logon.CREDUIWIN)"/>中
            ppvOutAuthBuffer所設定的BLOB認證一樣使用32位元的模式
            </summary>
        </member>
        <member name="T:TEC.Core.Security.Logon.CREDUI_FLAGS">
            <summary>
            在CredUIReturnCodes方法中的特殊行為，可以使用位元的OR來輸入一個或多個值
            </summary>
            <remarks>
            http://msdn.microsoft.com/zh-tw/library/aa375177.aspx
            </remarks>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_FLAGS.INCORRECT_PASSWORD">
            <summary>
            當使用者"登入失敗"時，以氣泡方式提示使用者
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_FLAGS.DO_NOT_PERSIST">
            <summary>
            不要顯示題是儲存密碼的核取方塊，並且也不要儲存輸入的密碼，您也可以透過
            <see cref="F:TEC.Core.Security.Logon.CREDUI_FLAGS.SHOW_SAVE_CHECK_BOX"/>來只顯示"儲存"的核取方塊，
            並且結果會透過out參數pfSave傳回
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_FLAGS.REQUEST_ADMINISTRATOR">
            <summary>
            在選擇帳號的下拉式選單中僅顯示本機系統管理員
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_FLAGS.EXCLUDE_CERTIFICATES">
            <summary>
            在選擇使用者的選單中不要顯示"以智慧卡登入"的選項
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_FLAGS.REQUIRE_CERTIFICATE">
            <summary>
            在選擇使用者的選單中僅顯示"以智慧卡登入"以及現有認證的選項，並且無法輸入使用者名稱
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_FLAGS.SHOW_SAVE_CHECK_BOX">
            <summary>
            顯示"儲存密碼"的核取方塊，可以透過pfSave參數來指定顯示認證視窗時預設是否要核取
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_FLAGS.ALWAYS_SHOW_UI">
            <summary>
            如果認證管理員中已經存有相關的認證，是否仍要顯示認證視窗，這個值只有同時設定
            <see cref="F:TEC.Core.Security.Logon.CREDUI_FLAGS.GENERIC_CREDENTIALS"/>時才會生效
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_FLAGS.REQUIRE_SMARTCARD">
            <summary>
            在選擇使用者的選單中僅顯示"以智慧卡登入"或者是現有認證的選項，並且無法輸入使用者名稱
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_FLAGS.PASSWORD_ONLY_OK">
            <summary>
            選單中只填入相關的密碼，並且無法輸入使用者名稱
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_FLAGS.VALIDATE_USERNAME">
            <summary>
            檢查使用者名稱是否合乎 Domain\username 或 username@Domain 的格式
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_FLAGS.COMPLETE_USERNAME">
            <summary>
            選單中的資料是否要用完整的使用者名稱(Domain\USername)
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_FLAGS.PERSIST">
            <summary>
            不要顯示"儲存密碼"的核取方塊，但認證仍會在當顯示核取方塊且被核取時儲存
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_FLAGS.SERVER_CREDENTIAL">
            <summary>
            這將會在輸入使用者時預先填入已儲存的使用者名稱，不論該認證是否正確。
            並且萬用字元不在預填入的範圍內，CredUI不會建立包含萬用字元的認證。
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_FLAGS.EXPECT_CONFIRMATION">
            <summary>
            指定呼叫者會呼叫<see cref="M:TEC.Core.Security.Logon.AuthenticationPrompt.CredUIPromptForCredentials(TEC.Core.Security.Logon.CREDUI_INFO@,System.String,System.IntPtr,System.Int32,System.Text.StringBuilder,System.Int32,System.Text.StringBuilder,System.Int32,System.Boolean@,TEC.Core.Security.Logon.CREDUI_FLAGS)"/>來確定該認證使否真的存在，
            這種機制可以確定只有確實存在的認證才會被儲存，反之則不會。
            這個Flag應該要包含在任何案例中，除非<see cref="F:TEC.Core.Security.Logon.CREDUI_FLAGS.DO_NOT_PERSIST"/>已包含於該案例中
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_FLAGS.GENERIC_CREDENTIALS">
            <summary>
            讓輸入的相關認證成為"一般認證(Generic Credentials)"
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_FLAGS.USERNAME_TARGET_CREDENTIALS">
            <summary>
            這是以"用..身分執行"的認證， CredUIConfirmCredentials的TargerName參數將會是要執行的命令或程式，這只用於提示使用者輸入的標的。
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_FLAGS.KEEP_USERNAME">
            <summary>
            無法更改提供的使用者名稱
            </summary>
        </member>
        <member name="T:TEC.Core.Security.Logon.CREDUI_INFO">
            <summary>
            本結構係為了傳遞資訊到提供認證視窗的<see cref="M:TEC.Core.Security.Logon.AuthenticationPrompt.CredUIPromptForCredentials(TEC.Core.Security.Logon.CREDUI_INFO@,System.String,System.IntPtr,System.Int32,System.Text.StringBuilder,System.Int32,System.Text.StringBuilder,System.Int32,System.Boolean@,TEC.Core.Security.Logon.CREDUI_FLAGS)"/>方法
            </summary>
            <remarks>
            http://msdn.microsoft.com/zh-tw/library/aa375183.aspx
            </remarks>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_INFO.cbSize">
            <summary>
            設定或取得 CREDUI_INFO 結構的大小
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_INFO.hwndParent">
            <summary>
            設定或取得認證資訊視窗的父視窗，如果這個值為null，則會將桌面設定為其父視窗。
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_INFO.pszMessageText">
            <summary>
            設定或取得認證資訊視窗要顯示的內文
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_INFO.pszCaptionText">
            <summary>
            設定或取得認證資訊視窗的標題
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.CREDUI_INFO.hbmBanner">
            <summary>
            設定或取得要顯示在認證視窗內的圖片(Bitmap)，其大小限制為320*60像素。
            </summary>
        </member>
        <member name="T:TEC.Core.Security.Logon.LogonProvider">
            <summary>
            登入提供者
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.LogonProvider.LOGON32_PROVIDER_DEFAULT">
            <summary>
            使用該系統的基本登入提供者，預設安全性提供者為交涉驗證(negotiate)，
            除非您將網域名稱設定為null以及使用名稱非UPN格式，目前而言，預設提供者是NTLM。
            注意：當系統為Windows 2000/NT時，預設安全性提供者是NTLM
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.LogonProvider.LOGON32_PROVIDER_WINNT35">
            <summary>
            Windows NT 3.5 登入提供者
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.LogonProvider.LOGON32_PROVIDER_WINNT40">
            <summary>
             NTLM 登入提供者
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.LogonProvider.LOGON32_PROVIDER_WINNT50">
            <summary>
            交涉驗證 登入提供者
            </summary>
        </member>
        <member name="T:TEC.Core.Security.Logon.LogonType">
            <summary>
            Windows 登入方式的列舉
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.LogonType.LOGON32_LOGON_INTERACTIVE">
            <summary>
            本登入類型適用於要與電腦互動的使用者，舉一個使用者的例子來說，他可以透過終端伺服器、遠端指令等類似的程式來登入。
            這種登入類型當中斷操作時，會因為快取使用者的登入資訊造成額外的負擔，因此，這種登入方式不是用於client/server的應用程式。
            如郵件伺服器(mail server)等等。
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.LogonType.LOGON32_LOGON_NETWORK">
            <summary>
            本登入類型適用於讓高效能的伺服器來驗證明文密碼。
            本方式的LogonUser方法不會快取任何認證(Credentials)。
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.LogonType.LOGON32_LOGON_BATCH">
            <summary>
            本登入類型適用於批次伺服器(batch servers)，程式有可能被某個代表使用者執行，換句話說，這個程式並不是由使用者直接執行的。
            本登入類型也適用於讓高效能的伺服器來同時驗證多組明文密碼，舉例來說，像是郵件或是網路伺服器。
            本方式的LogonUser方法不會快取任何認證(Credentials)。
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.LogonType.LOGON32_LOGON_SERVICE">
            <summary>
            以服務類型為登入方式，所提供的帳戶必須要允許「透過服務方式登入」。
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.LogonType.LOGON32_LOGON_UNLOCK">
            <summary>
            本登入類型讓使用者能用GINA DLL來跟電腦互動的登入方式。
            當工作站被鎖定時，本登入類型能在工作站解除鎖定時產生可被識別的稽核紀錄。
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.LogonType.LOGON32_LOGON_NETWORK_CLEARTEXT">
            <summary>
            本登入類型將會將帳號與密碼保留在認證模組中，這樣可以讓工作站模擬使用者連接其他網路上的伺服器，
            伺服器可以接受客戶端的明文認證，透過LogonUser方法，驗證該使用者可以存取網路上的系統，並且仍然可以與其他伺服器溝通。
            注意：本方法不適用於 Windows NT
            </summary>
        </member>
        <member name="F:TEC.Core.Security.Logon.LogonType.LOGON32_LOGON_NEW_CREDENTIALS">
            <summary>
            本登入類型可以讓呼叫者複製目前的token並且為連出的連接指定新的認證。
            新的登入階段仍會有相同的本機識別，但對於其他網路連線而言將會是使用不同的認證。
            注意：本登入類型指使用於透過 LOGON32_PROVIDER_WINNT50 為登入提供者
            注意：本方法不適用於 Windows NT
            </summary>
        </member>
        <member name="T:TEC.Core.Security.Logon.WindowsImpersonation">
            <summary>
            模擬使用者資料的類別
            </summary>
        </member>
        <member name="M:TEC.Core.Security.Logon.WindowsImpersonation.undoImpersonationUser">
            <summary>
            當有模擬的對象時，取消模擬該使用者
            </summary>
            <remarks>當沒有模擬使用者時，不會發生任何事情</remarks>
        </member>
        <member name="M:TEC.Core.Security.Logon.WindowsImpersonation.impersonateValidUser(System.String,System.String,System.String,TEC.Core.Security.Logon.LogonType,TEC.Core.Security.Logon.LogonProvider)">
            <summary>
            模擬其他使用者的登入
            </summary>
            <param name="userName">使用者帳號</param>
            <param name="domain">網域</param>
            <param name="password">密碼</param>
            <param name="logonType">登入類型</param>
            <param name="logonProvider">登入驗證提供者</param>
            <returns>是否驗證成功以及登入完成</returns>
            <example>
            <code lang="C#">
            /// &lt;summary&gt;
            /// 模擬其他使用者的登入
            /// &lt;/summary&gt;
            /// &lt;param name="userName"&gt;使用者帳號&lt;/param&gt;
            /// &lt;param name="domain"&gt;網域&lt;/param&gt;
            /// &lt;param name="password"&gt;密碼&lt;/param&gt;
            /// &lt;returns&gt;是否驗證成功以及登入完成&lt;/returns&gt;
            public static bool impersonateValidUser(string userName, string domain, string password)
            {
               if (WindowsImpersonation.impersonateValidUser(userName, domain, password, LogonType.LOGON32_LOGON_INTERACTIVE, LogonProvider.LOGON32_PROVIDER_DEFAULT))
               {
                   //這裡所執行的程式碼都是由該模擬出來的人所執行的
                    string impersonatedUSerName = WindowsIdentity.GetCurrent().Name;
                   return true;
               }
               else
               {
                   //認證失敗，這裡可以處理正失敗後的結果
                   return false;
               }
            }
            </code>
            </example>
            <remarks>
            <para>當要返回原有使用者時，請叫用WindowsImpersonation.undoImpersonationUser()方法</para>
            <para>如要搭配Windows內建登入視窗，請參考<see cref="T:TEC.Core.Security.Logon.AuthenticationPrompt"/></para>
            </remarks>
        </member>
        <member name="T:TEC.Core.ServiceProcess.ServiceControllerStatusChangedEventArgs">
            <summary>
            當服務執行狀態改變時的事件參數
            </summary>
        </member>
        <member name="M:TEC.Core.ServiceProcess.ServiceControllerStatusChangedEventArgs.#ctor(System.Nullable{System.ServiceProcess.ServiceControllerStatus},System.Nullable{System.ServiceProcess.ServiceControllerStatus})">
            <summary>
            初始化事件參數
            </summary>
            <param name="oldValue">舊值</param>
            <param name="newValue">新值</param>
        </member>
        <member name="P:TEC.Core.ServiceProcess.ServiceControllerStatusChangedEventArgs.OldValue">
            <summary>
            取得狀態變換前的值
            </summary>
        </member>
        <member name="P:TEC.Core.ServiceProcess.ServiceControllerStatusChangedEventArgs.NewValue">
            <summary>
            取得狀態變換後的值
            </summary>
        </member>
        <member name="T:TEC.Core.ServiceProcess.ServiceInformation">
            <summary>
            儲存服務狀態的類別
            </summary>
            <example>
            <code lang="C#">
            //Example1:-----------------------------------------------------------------
            //初始化本機w3svc服務監控
            ServiceInformation serviceInformation_W3SVC = new ServiceInformation("W3SVC", ".");
            serviceInformation_W3SVC.RefreshCompleted += (sender, e) =&gt;
            {
                ServiceInformation serviceInformation = sender as ServiceInformation;
                Console.WriteLine("Name:{0} is refreshed on {1:yyyy/MM/dd HH:mm:ss}",
                     serviceInformation.ServiceName, DateTime.Now);
            };
            //重新整理狀態
            serviceInformation_W3SVC.refresh();
            Console.WriteLine("Name:{0},RunningStatus:{1},InstallStatus:{2}",
                serviceInformation_W3SVC.ServiceName,
                serviceInformation_W3SVC.ServiceControllerStatus.HasValue ? serviceInformation_W3SVC.ServiceControllerStatus.Value.ToString() : "Unknown",
                serviceInformation_W3SVC.ServiceInstallStatus.ToString());
            //
            //Example2:-----------------------------------------------------------------
            //初始化本機不存在的服務監控
            ServiceInformation serviceInformation_NotExist = new ServiceInformation("NotExist", ".");
            serviceInformation_NotExist.PropertyChanged += (sender, e) =&gt;
            {
                //屬性變更時引發此事件
                Console.WriteLine("Name:{0},RunningStatus:{1},InstallStatus:{2}",
                    serviceInformation_NotExist.ServiceName,
                    serviceInformation_NotExist.ServiceControllerStatus.HasValue ? serviceInformation_NotExist.ServiceControllerStatus.Value.ToString() : "Unknown",
                    serviceInformation_NotExist.ServiceInstallStatus.ToString());
            };
            serviceInformation_NotExist.RefreshCompleted += (sender, e) =&gt;
            {
                //非同步更新完成後執行此行
                ServiceInformation serviceInformation = sender as ServiceInformation;
                Console.WriteLine("Name:{0} is refreshed on {1:yyyy/MM/dd HH:mm:ss}",
                     serviceInformation.ServiceName, DateTime.Now);
            };
            //非同步重新整理，並在重新整理完成時並將變更狀態的動作附加至指定的執行緒上
            serviceInformation_NotExist.refreshAsync();
            //當重新整理尚未完成時，下方程式碼會直接終止並重新開始讀取。
            serviceInformation_NotExist.refreshAsync();
            //以下的狀態在執行緒尚未更新至ServiceInformation前，狀態都不是最新的
            Console.WriteLine("Name:{0},RunningStatus:{1},InstallStatus:{2}",
            serviceInformation_NotExist.ServiceName,
            serviceInformation_NotExist.ServiceControllerStatus.HasValue ? serviceInformation_NotExist.ServiceControllerStatus.Value.ToString() : "Unknown",
            serviceInformation_NotExist.ServiceInstallStatus.ToString());
            Console.ReadKey();
            </code>
            </example>
            <remarks>
            若需要定期執行更新，請搭配「TEC Scheduler Library(Nuget套件)」中的排程器使用
            </remarks>
        </member>
        <member name="M:TEC.Core.ServiceProcess.ServiceInformation.#ctor(System.String,System.String)">
            <summary>
            初始化儲存服務狀態的物件
            </summary>
            <param name="serviceName">服務名稱</param>
            <param name="machineName">存放服務的機器名稱</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="serviceName"/>為空值或空白時擲出</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="machineName"/>為空值或空白時擲出</exception>
        </member>
        <member name="M:TEC.Core.ServiceProcess.ServiceInformation.Finalize">
            <summary>
            解構物件
            </summary>
        </member>
        <member name="M:TEC.Core.ServiceProcess.ServiceInformation.Dispose">
            <summary>
            執行與釋放 (Free)、釋放 (Release) 或重設 Unmanaged 資源相關聯之應用程式定義的工作。
            </summary>
        </member>
        <member name="M:TEC.Core.ServiceProcess.ServiceInformation.refresh(System.Security.Principal.WindowsIdentity)">
            <summary>
            立即重新整理目前服務的狀態
            </summary>
            <param name="windowsIdentity">用於重新整理服務狀態的驗證，<c lang="C#">null</c>為使用目前驗證</param>
            <remarks>若沒有更新<see cref="P:TEC.Core.ServiceProcess.ServiceInformation.ServiceInstallStatus"/>以及<see cref="P:TEC.Core.ServiceProcess.ServiceInformation.ServiceControllerStatus"/>，請確定目前執行緒服務為可被執排程執行(通常為UI執行緒)</remarks>
        </member>
        <member name="M:TEC.Core.ServiceProcess.ServiceInformation.refreshAsync(System.Security.Principal.WindowsIdentity)">
            <summary>
            立即建立並啟動新的執行緒，重新整理目前服務的狀態，當先前已經呼叫過但還沒執行完成時，將會終止目前執行緒並重新建立之。
            </summary>
            <param name="windowsIdentity">用於重新整理服務狀態的驗證，<c lang="C#">null</c>為使用目前驗證</param>
        </member>
        <member name="M:TEC.Core.ServiceProcess.ServiceInformation.getInformation(System.Security.Principal.WindowsIdentity)">
            <summary>
            依照指定認證傳回目前服務最新的狀態
            </summary>
            <param name="windowsIdentity">用於重新整理服務狀態的驗證，<c lang="C#">null</c>為使用目前驗證</param>
        </member>
        <member name="M:TEC.Core.ServiceProcess.ServiceInformation.Dispose(System.Boolean)">
            <summary>
            釋放目前物件的資源
            </summary>
            <param name="isDisposing">是否開始處理物件的資源釋放行為</param>
        </member>
        <member name="P:TEC.Core.ServiceProcess.ServiceInformation.ServiceInstallStatus">
            <summary>
            取得目前服務的安裝狀態
            </summary>
        </member>
        <member name="P:TEC.Core.ServiceProcess.ServiceInformation.ServiceControllerStatus">
            <summary>
            取得目前服務的執行狀態
            </summary>
        </member>
        <member name="P:TEC.Core.ServiceProcess.ServiceInformation.RefreshServiceStatusThread">
            <summary>
            設定或取得重新整理服務狀態所使用的執行緒
            </summary>
        </member>
        <member name="P:TEC.Core.ServiceProcess.ServiceInformation.ServiceController">
            <summary>
            取得目前儲存物件相對應的<seealso cref="T:System.ServiceProcess.ServiceController"/>
            </summary>
        </member>
        <member name="P:TEC.Core.ServiceProcess.ServiceInformation.ServiceName">
            <summary>
            取得服務名稱
            </summary>
        </member>
        <member name="P:TEC.Core.ServiceProcess.ServiceInformation.MachineName">
            <summary>
            取得機器名稱
            </summary>
        </member>
        <member name="E:TEC.Core.ServiceProcess.ServiceInformation.InstallStatusChanged">
            <summary>
            當安裝狀態變化時要執行的事件
            </summary>
        </member>
        <member name="E:TEC.Core.ServiceProcess.ServiceInformation.ServiceControllerStatusChanged">
            <summary>
            當服務狀態變化時要執行的事件
            </summary>
        </member>
        <member name="E:TEC.Core.ServiceProcess.ServiceInformation.RefreshCompleted">
            <summary>
            當每次重新整理服務(同步以及非同步)處理完成時會引發的事件
            </summary>
        </member>
        <member name="T:TEC.Core.ServiceProcess.ServiceInstallStatus">
            <summary>
            服務狀態的列舉
            </summary>
        </member>
        <member name="F:TEC.Core.ServiceProcess.ServiceInstallStatus.NotInstalled">
            <summary>
            未安裝
            </summary>
        </member>
        <member name="F:TEC.Core.ServiceProcess.ServiceInstallStatus.Installed">
            <summary>
            已安裝
            </summary>
        </member>
        <member name="F:TEC.Core.ServiceProcess.ServiceInstallStatus.AccessDenied">
            <summary>
            存取被拒
            </summary>
        </member>
        <member name="F:TEC.Core.ServiceProcess.ServiceInstallStatus.Unknown">
            <summary>
            未知
            </summary>
        </member>
        <member name="T:TEC.Core.ServiceProcess.ServiceInstallStatusChangedEventArgs">
            <summary>
            當服務安裝狀態改變時的事件參數
            </summary>
        </member>
        <member name="M:TEC.Core.ServiceProcess.ServiceInstallStatusChangedEventArgs.#ctor(TEC.Core.ServiceProcess.ServiceInstallStatus,TEC.Core.ServiceProcess.ServiceInstallStatus)">
            <summary>
            初始化事件參數
            </summary>
            <param name="oldValue">舊值</param>
            <param name="newValue">新值</param>
        </member>
        <member name="P:TEC.Core.ServiceProcess.ServiceInstallStatusChangedEventArgs.OldValue">
            <summary>
            取得狀態變換前的值
            </summary>
        </member>
        <member name="P:TEC.Core.ServiceProcess.ServiceInstallStatusChangedEventArgs.NewValue">
            <summary>
            取得狀態變換後的值
            </summary>
        </member>
        <member name="T:TEC.Core.Settings.Collections.CachedValueConfig`1">
            <summary>
            用於<see cref="T:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3"/>的產生快取值的設定類別
            </summary>
            <typeparam name="TValue">產生值的快取設定</typeparam>
        </member>
        <member name="M:TEC.Core.Settings.Collections.CachedValueConfig`1.#ctor(`0,System.Runtime.Caching.CacheItemPolicy)">
            <summary>
            初始化快取單一值的資訊
            </summary>
            <param name="value">要快取的值</param>
            <param name="cacheItemPolicy">快取回收和期限詳細資料</param>
            <exception cref="T:System.ArgumentNullException">當<paramref name="cacheItemPolicy"/>為<c lang="C#">null</c>時發生</exception>
        </member>
        <member name="P:TEC.Core.Settings.Collections.CachedValueConfig`1.CacheItemPolicy">
            <summary>
            取得快取回收和期限詳細資料
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Collections.CachedValueConfig`1.Value">
            <summary>
            取得相關的快取值
            </summary>
        </member>
        <member name="T:TEC.Core.Settings.Collections.CachedValueGeneratedEventArgs`2">
            <summary>
            當<see cref="T:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3"/>設定檔集合中的快取值產生時引發的事件參數
            </summary>
        </member>
        <member name="M:TEC.Core.Settings.Collections.CachedValueGeneratedEventArgs`2.#ctor(`0,`1,System.Runtime.Caching.CacheItemPolicy)">
            <summary>
            初始化當<see cref="T:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3"/>設定檔集合中的快取值產生時引發的事件參數
            </summary>
            <param name="key">引發事件的索引鍵</param>
            <param name="value">產生快取的值</param>
            <param name="cacheItemPolicy">關於此快取的收回和期限詳細資料</param>
        </member>
        <member name="P:TEC.Core.Settings.Collections.CachedValueGeneratedEventArgs`2.Key">
            <summary>
            取得索引鍵
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Collections.CachedValueGeneratedEventArgs`2.Value">
            <summary>
            取得產生的值
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Collections.CachedValueGeneratedEventArgs`2.CacheItemPolicy">
            <summary>
            取得產生後的收回和期限詳細資料
            </summary>
        </member>
        <member name="T:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3">
            <summary>
            針對每個索引對應到的值，予以個別快取措施的設定檔集合。
            </summary>
            <typeparam name="TKey">設定檔集合中之索引鍵的型別(建議為列舉)。</typeparam>
            <typeparam name="TValue"> 設定檔之值的型別。</typeparam>
            <typeparam name="TCollectionId">設定檔索引鍵之型別</typeparam>
            <example>
            <para>
            SomeCachedSettingCollection.cs
            </para>
            <code lang="C#">
            using System;
            using TEC.Core.Settings.Collections;
            namespace TEC.Core.TestConsole.Settings.Collections
            {
                /// &lt;summary&gt;
                /// 測試快取設定檔集合
                /// &lt;/summary&gt;
                public class SomeCachedSettingCollection :
                    TEC.Core.Settings.Collections.CachedValueSettingCollectionBase&lt;SomeCachedSettingEnum, object, string&gt;
                {
                    /// &lt;summary&gt;
                    /// 初始化測試快取設定檔集合的物件
                    /// &lt;/summary&gt;
                    public SomeCachedSettingCollection()
                        : base("CachedCollectionId", System.Runtime.Caching.MemoryCache.Default) { }
                    /// &lt;summary&gt;
                    /// 當目前索引鍵無法對應到產生快取的方法封裝時，用於取得產生快取值的方法封裝
                    /// &lt;/summary&gt;
                    /// &lt;param name="key"&gt;要取得方法封裝的索引鍵&lt;/param&gt;
                    /// &lt;returns&gt;傳回產生 CachedValueConfig&lt;object&gt; 的方法封裝&lt;/returns&gt;
                    protected override Func&lt;CachedValueConfig&lt;object&gt;&gt; getSettingGenerateFunc(SomeCachedSettingEnum key)
                    {
                        //using TEC.Core.Settings.Collections;
                        switch (key)
                        {
                            case SomeCachedSettingEnum.Setting1:
                                return () =&gt; new CachedValueConfig&lt;object&gt;(1, new System.Runtime.Caching.CacheItemPolicy()
                                {
                                    //Setting1 在每30秒後過期一次
                                    AbsoluteExpiration = DateTime.Now.AddSeconds(30d)
                                });
                            case SomeCachedSettingEnum.Setting2:
                                return () =&gt; new CachedValueConfig&lt;object&gt;("Test", new System.Runtime.Caching.CacheItemPolicy()
                                {
                                    //Setting2 在每15秒後過期一次
                                    AbsoluteExpiration = DateTime.Now.AddSeconds(15d)
                                });
                            case SomeCachedSettingEnum.Setting3:
                                return () =&gt;
                                {
                                    double value = new Random().NextDouble();
                                    //複雜邏輯
                                    return new CachedValueConfig&lt;object&gt;(value, new System.Runtime.Caching.CacheItemPolicy()
                                    {
                                        //Setting3 在每25秒後過期一次
                                        AbsoluteExpiration = DateTime.Now.AddSeconds(25d)
                                    });
                                };
                            default:
                                throw new NotImplementedException();
                        }
                    }
                }
                /// &lt;summary&gt;
                /// 測試設定檔列舉
                /// &lt;/summary&gt;
                public enum SomeCachedSettingEnum
                {
                    /// &lt;summary&gt;
                    /// Setting1, System.Int32
                    /// &lt;/summary&gt;
                    Setting1,
                    /// &lt;summary&gt;
                    /// Setting1, System.String
                    /// &lt;/summary&gt;
                    Setting2,
                    /// &lt;summary&gt;
                    /// Setting3, System.Double
                    /// &lt;/summary&gt;
                    Setting3
                }
            }
            </code>
            <para>SettingCollectionFactory.cs</para>
            <code lang="C#">
            using System;
            using System.IO;
            using TEC.Core.Settings.Providers;
            using TEC.Core.TestConsole.Settings.Collections;
            namespace TEC.Core.TestConsole.Settings
            {
                /// &lt;summary&gt;
                /// 用於產生設定檔的靜態類別
                /// &lt;/summary&gt;
                public static class SettingCollectionFactory
                {
                    /// &lt;summary&gt;
                    /// 取得系統唯一的快取設定檔集合
                    /// &lt;/summary&gt;
                    public static SomeCachedSettingCollection SomeCachedSettingCollection
                    {
                        get
                        {
                            ApplicationSettingProvider&lt;SomeCachedSettingCollection, SomeCachedSettingEnum, object, string&gt; provider =
                                new ApplicationSettingProvider&lt;SomeCachedSettingCollection, SomeCachedSettingEnum, object, string&gt;();
                            if (provider.load() == null)
                            {
                                provider.save(new SomeCachedSettingCollection());
                            }
                            return provider.load();
                        }
                    }
                }
            }
            </code>
            <para>SettingCollectionTest.cs</para>
            <code lang="C#">
            using System;
            using TEC.Core.TestConsole.Settings.Collections;
            namespace TEC.Core.TestConsole.Settings
            {
                public class SettingCollectionTest
                {
                    public static void main()
                    {
                        #region SomeCachedSettingCollection
                        SomeCachedSettingCollection someCachedSettingCollection = SettingCollectionFactory.SomeCachedSettingCollection;
                        someCachedSettingCollection.CachedValueGenerated += (sender, e) =&gt;
                        {
                            Console.WriteLine("設定檔「{0}」已於{1:yyyy/MM/dd HH:mm:ss}產生快取值:{2}", e.Key.ToString(), DateTime.Now, e.Value);
                        };
                        int value1 = (int)someCachedSettingCollection[SomeCachedSettingEnum.Setting1];
                        string value2 = someCachedSettingCollection[SomeCachedSettingEnum.Setting2].ToString();
                        double value3 = (double)someCachedSettingCollection[SomeCachedSettingEnum.Setting3];
                        #endregion
                    }
                }
            }
            </code>
            </example>
        </member>
        <member name="F:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.sync_keys_obj">
            <summary>
            用於控制刪除索引鍵的物件
            </summary>
        </member>
        <member name="M:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.#ctor(`2,System.Runtime.Caching.ObjectCache)">
            <summary>
            初始化對每個索引對應到的值，予以個別快取措施的設定檔集合。
            </summary>
            <param name="id">可以代表本集合的Id</param>
            <param name="objectCache">每個快取所使用的物件快取</param>
            <exception cref="T:System.ArgumentNullException">當<paramref name="objectCache"/>為<c lang="C#">null</c>時發生</exception>
        </member>
        <member name="M:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.TryGetValue(`0,`1@)">
            <summary>
            取得與指定設定檔索引鍵關聯的值
            </summary>
            <param name="key">要取得其值的設定檔索引</param>
            <param name="value">這個方法傳回時，如果找到索引鍵，則為與指定索引鍵關聯的值，否則為<typeparamref name="TValue"/>參數的型別預設值。 這個參數會以未初始化的狀態傳遞。</param>
            <returns>如果此集合之物件包含指定的設定檔，則為<c lang="C#">true</c>，否則為 <c lang="C#">false</c></returns>
            <exception cref="T:System.ArgumentNullException">key 為 null</exception>
        </member>
        <member name="P:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.Item(`0)">
            <summary>
            取得具有指定設定檔的項目，若無索引鍵項目，將讀取預設值並存入目前設定檔集合中
            </summary>
            <param name="key">要取得或設定之項目的索引鍵</param>
            <returns>傳回相對應的值</returns>
        </member>
        <member name="P:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.Values">
            <summary>
            取得此設定檔的所有值
            </summary>
        </member>
        <member name="M:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            傳回可逐一查看集合的列舉程式
            </summary>
            <returns>可以用來逐一查看集合的設定檔列舉程式</returns>
        </member>
        <member name="M:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.ContainsKey(`0)">
            <summary>
            判斷集合中是否含有指定設定檔索引
            </summary>
            <param name="key">在集合中要尋找索引鍵</param>
            <returns></returns>
        </member>
        <member name="P:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.Keys">
            <summary>
            取得目前設定檔集合中的所有設定索引鍵
            </summary>
        </member>
        <member name="M:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.Remove(`0)">
            <summary>
            將指定設定檔索引鍵的資料從此集合中移除
            </summary>
            <param name="key">要移除之項目的名稱</param>
            <returns>如果成功移除項目，則為 true，否則為 false。 
            如果在原始的 <see cref="T:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3"/>中找不到 <paramref name="key"/>
            ，則這個方法也會傳回 false。</returns>
        </member>
        <member name="M:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.System#Collections#Generic#IDictionary{TKey,TValue}#Add(`0,`1)">
            <summary>
            目前此類別不支援設定操作
            </summary>
            <param name="key">目前此類別不支援設定操作</param>
            <param name="value">目前此類別不支援設定操作</param>
        </member>
        <member name="P:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.System#Collections#Generic#IDictionary{TKey,TValue}#Item(`0)">
            <summary>
             取得具有指定設定檔的項目，若無索引鍵項目，將讀取預設值並存入目前設定檔集合中。目前此類別不支援設定操作。
            </summary>
            <param name="key">要取得值的索引鍵</param>
            <returns></returns>
        </member>
        <member name="M:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            目前此類別不支援設定操作
            </summary>
            <param name="item">目前此類別不支援設定操作</param>
        </member>
        <member name="M:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            目前此類別不支援設定操作
            </summary>
            <param name="item">目前此類別不支援設定操作</param>
            <returns></returns>
        </member>
        <member name="M:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            目前此類別不支援設定操作
            </summary>
            <param name="array">目前此類別不支援設定操作</param>
            <param name="arrayIndex">目前此類別不支援設定操作</param>
        </member>
        <member name="M:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            目前此類別不支援設定操作
            </summary>
            <param name="item">目前此類別不支援設定操作</param>
            <returns></returns>
        </member>
        <member name="M:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.Clear">
            <summary>
            將所有項目從設定檔以及快取中移除
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.Count">
            <summary>
            取得目前設定檔集合中所包含的元素個數
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.IsReadOnly">
            <summary>
            取得值，指出此設定檔集合是否為唯讀，此值傳回<c lang="C#">false</c>
            </summary>
        </member>
        <member name="M:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.GetEnumerator">
            <summary>
            傳回可逐一查看集合的列舉程式
            </summary>
            <returns>可以用來逐一查看集合的設定檔列舉程式</returns>
        </member>
        <member name="M:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.getIsValueCached(`0)">
            <summary>
            取得指定索引鍵的快取值是否已經在快取中並且尚未被清除
            </summary>
            <param name="key">要取得其值是否已經存在快取的索引鍵</param>
            <returns>若已經存在，傳回<c>true</c>；若不存在，則傳回<c>fasle</c>。</returns>
        </member>
        <member name="M:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.getValueFromCache(`0)">
            <summary>
            從快取中取得指定的值，若快取中沒有值，則會呼叫委派方法產生之並存入快取中
            </summary>
            <param name="key">要取得其值的索引</param>
            <returns>快取值。</returns>
        </member>
        <member name="M:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.removeValueFromCache(`0)">
            <summary>
            從快取中移除指定的值
            </summary>
            <param name="key">要移除值的索引鍵</param>
            <returns>傳回移除的<typeparamref name="TValue"/>，若沒有移除任何值則傳回<c lang="C#">null</c></returns>
        </member>
        <member name="M:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.formatCacheKey(`0)">
            <summary>
            格式化指定索引鍵用於快取的快取索引鍵
            </summary>
            <param name="key">要格式化的<typeparamref name="TKey"/></param>
            <returns></returns>
        </member>
        <member name="M:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.getSettingGenerateFunc(`0)">
            <summary>
            當目前索引鍵無法對應到產生快取的方法封裝時，用於取得產生快取值的方法封裝
            </summary>
            <param name="key">要取得方法封裝的索引鍵</param>
            <returns>傳回產生<see cref="T:TEC.Core.Settings.Collections.CachedValueConfig`1"/>的方法封裝</returns>
        </member>
        <member name="P:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.Id">
            <summary>
            取得可以代表集合的Id
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.ObjectCache">
            <summary>
            相關的物件快取
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.ThreadSafeObservableCollection">
            <summary>
            設定或取得受管理的集合
            </summary>
        </member>
        <member name="E:TEC.Core.Settings.Collections.CachedValueSettingCollectionBase`3.CachedValueGenerated">
            <summary>
            當快取重新產生(或新產生)時引發
            </summary>
        </member>
        <member name="T:TEC.Core.Settings.Collections.Resources.CachedValueSettingCollectionBase">
            <summary>
              用於查詢當地語系化字串等的強類型資源類別。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Collections.Resources.CachedValueSettingCollectionBase.ResourceManager">
            <summary>
              傳回這個類別使用的快取的 ResourceManager 執行個體。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Collections.Resources.CachedValueSettingCollectionBase.Culture">
            <summary>
              覆寫目前執行緒的 CurrentUICulture 屬性，對象是所有
              使用這個強類型資源類別的資源查閱。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Collections.Resources.CachedValueSettingCollectionBase.CachedIsRemovedAfterSetting">
            <summary>
              查詢類似 The &quot;{0}&quot; is successfully generated, but it is removed right away after adding to memory cache, please check cache item policy(CacheItemPolicy)  to solve this problem. 的當地語系化字串。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Collections.Resources.CachedValueSettingCollectionBase.NotSupportedFeature">
            <summary>
              查詢類似 CachedValueSettingCollection is not support this operation. 的當地語系化字串。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Collections.Resources.CachedValueSettingCollectionBase.SettingAlreadyExistExceptionMessage">
            <summary>
              查詢類似 The setting key &quot;{0}&quot; is already a member of the setting collection, if you want to update the value, please use the indexer. 的當地語系化字串。
            </summary>
        </member>
        <member name="T:TEC.Core.Settings.Collections.Resources.SettingCollectionBase">
            <summary>
              用於查詢當地語系化字串等的強類型資源類別。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Collections.Resources.SettingCollectionBase.ResourceManager">
            <summary>
              傳回這個類別使用的快取的 ResourceManager 執行個體。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Collections.Resources.SettingCollectionBase.Culture">
            <summary>
              覆寫目前執行緒的 CurrentUICulture 屬性，對象是所有
              使用這個強類型資源類別的資源查閱。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Collections.Resources.SettingCollectionBase.SettingAlreadyExistExceptionMessage">
            <summary>
              查詢類似 The setting key &quot;{0}&quot; is already a member of the setting collection, if you want to update the value, please use the indexer. 的當地語系化字串。
            </summary>
        </member>
        <member name="T:TEC.Core.Settings.Collections.SettingAlreadyExistException">
            <summary>
            當設定已經存在時的例外
            </summary>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingAlreadyExistException.#ctor">
            <summary>
            初始化 SettingAlreadyExistException 類別的新執行個體。
            </summary>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingAlreadyExistException.#ctor(System.String)">
            <summary>
            初始化 SettingAlreadyExistException 類別的新執行個體。
            </summary>
            <param name="message">描述錯誤的訊息</param>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingAlreadyExistException.#ctor(System.String,System.Exception)">
            <summary>
            初始化 SettingAlreadyExistException 類別的新執行個體。
            </summary>
            <param name="message">描述錯誤的訊息</param>
            <param name="innerException">目前例外狀況原因的例外狀況，如果沒有指定內部例外狀況，則為 Null 參考 (Visual Basic 中的 Nothing)</param>
        </member>
        <member name="T:TEC.Core.Settings.Collections.SettingCollectionBase`3">
            <summary>
            設定檔的基礎類別
            </summary>
            <typeparam name="TKey">設定索引鍵(建議為列舉)</typeparam>
            <typeparam name="TValue"> 字典中之值的型別。</typeparam>
            <typeparam name="TCollectionId">設定檔索引鍵之型別</typeparam>
            <remarks>
            若<typeparamref name="TKey"/>不為列舉型別，請自行複寫屬性<see cref="P:TEC.Core.Settings.Collections.SettingCollectionBase`3.DefaultValues"/>
            </remarks>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingCollectionBase`3.#ctor(`2)">
            <summary>
            初始化設定檔集合
            </summary>
            <param name="id">可以代表本集合的Id</param>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingCollectionBase`3.getDifferentSettings(TEC.Core.Settings.Collections.SettingCollectionBase{`0,`1,`2},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            比較兩設定集合，並傳回比較後相異的物件複本，修改傳回物件時，不會影響到來源以及被比較的設定集合值
            </summary>
            <param name="comparedSource">要比較的設定集合</param>
            <param name="comparer">用於比較集合中<typeparamref name="TValue"/>的比較方法，若此值為<c lang="C#">null</c>時將以預設的Equals方法進行比較。</param>
            <returns>相異的物件副本清單</returns>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingCollectionBase`3.GetSchema">
            <summary>
            本方法必定傳回null
            </summary>
            <returns></returns>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingCollectionBase`3.ReadXml(System.Xml.XmlReader)">
            <summary>
            從物件的 XML 表示產生該物件
            </summary>
            <param name="reader">還原序列化物件的 System.Xml.XmlReader 資料流</param>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingCollectionBase`3.WriteXml(System.Xml.XmlWriter)">
            <summary>
            將物件轉換成其 XML 表示
            </summary>
            <param name="writer">序列化物件的 System.Xml.XmlWriter 資料流</param>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingCollectionBase`3.Clone">
            <summary>
            建立目前執行個體複本的新物件
            </summary>
            <returns>這個新執行個體複本的新物件</returns>
        </member>
        <member name="P:TEC.Core.Settings.Collections.SettingCollectionBase`3.Item(`0)">
            <summary>
            取得或設定具有指定設定檔的項目，若無索引鍵項目，將讀取預設值並存入目前設定檔集合中
            </summary>
            <param name="key">要取得或設定之項目的索引鍵</param>
            <returns>傳回相對應的值，若該值不存在，則傳回預設值</returns>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingCollectionBase`3.Add(`0,`1)">
            <summary>
            將指定的設定加入集合
            </summary>
            <param name="key">要加入集合的設定索引鍵</param>
            <param name="value">要加入集合的索引鍵相對應的值</param>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingCollectionBase`3.Clear">
            <summary>
            將所有項目從設定檔移除
            </summary>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingCollectionBase`3.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            判斷集合是否包含特定設定檔
            </summary>
            <param name="item">要在集合中尋找的設定資料</param>
            <returns></returns>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingCollectionBase`3.ContainsKey(`0)">
            <summary>
            判斷集合中是否含有指定設定檔索引
            </summary>
            <param name="key">在集合中要尋找索引鍵</param>
            <returns></returns>
        </member>
        <member name="P:TEC.Core.Settings.Collections.SettingCollectionBase`3.Keys">
            <summary>
            取得目前設定檔集合中的所有設定索引鍵
            </summary>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingCollectionBase`3.Remove(`0)">
            <summary>
            將指定設定檔索引鍵的資料從此集合中移除
            </summary>
            <param name="key">要移除之項目的名稱</param>
            <returns>如果成功移除項目，則為 true，否則為 false。 
            如果在原始的 <see cref="T:TEC.Core.Settings.Collections.SettingCollectionBase`3"/>中找不到 <paramref name="key"/>
            ，則這個方法也會傳回 false。</returns>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingCollectionBase`3.TryGetValue(`0,`1@)">
            <summary>
            取得與指定設定檔索引鍵關聯的值
            </summary>
            <param name="key">要取得其值的設定檔索引</param>
            <param name="value">這個方法傳回時，如果找到索引鍵，則為與指定索引鍵關聯的值，否則為<typeparamref name="TValue"/>參數的型別預設值。 這個參數會以未初始化的狀態傳遞。</param>
            <returns>如果此集合之物件包含指定的設定檔，則為<c lang="C#">true</c>，否則為 <c lang="C#">false</c></returns>
            <exception cref="T:System.ArgumentNullException">key 為 null</exception>
        </member>
        <member name="P:TEC.Core.Settings.Collections.SettingCollectionBase`3.Values">
            <summary>
            取得此設定檔的所有值
            </summary>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingCollectionBase`3.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            將設定檔項目加入至目前的集合中
            </summary>
            <param name="item">要加入到目前集合的設定</param>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingCollectionBase`3.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
             從特定的設定檔索引開始，複製目前設定的集合項目至指定的陣列中。
            </summary>
            <param name="array">從目前設定檔集合複製之目的端</param>
            <param name="arrayIndex">array中以零起始的索引，是複製開始的位置</param>
            <exception cref="T:System.ArgumentNullException">array為null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex小於0</exception>
            <exception cref="T:System.ArgumentException">目前設定檔集合元素的數量大於從 arrayIndex 到目的 array</exception>
        </member>
        <member name="P:TEC.Core.Settings.Collections.SettingCollectionBase`3.Count">
            <summary>
            取得目前設定檔集合中所包含的元素個數
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Collections.SettingCollectionBase`3.IsReadOnly">
            <summary>
            取得值，指出此設定檔集合是否為唯讀
            </summary>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingCollectionBase`3.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            從目前設定檔集合中移除特定物件的第一個相符項目
            </summary>
            <param name="item">要移除的物件</param>
            <returns>如果<paramref name="item"/>以成功從目前的集合移除，則為 <c lang="C#">true</c>，否則為 <c lang="C#">false</c>。</returns>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingCollectionBase`3.GetEnumerator">
            <summary>
            傳回可逐一查看集合的列舉程式
            </summary>
            <returns>可以用來逐一查看集合的設定檔列舉程式</returns>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingCollectionBase`3.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            傳回可逐一查看集合的列舉程式
            </summary>
            <returns>可以用來逐一查看集合的設定檔列舉程式</returns>
        </member>
        <member name="P:TEC.Core.Settings.Collections.SettingCollectionBase`3.Id">
            <summary>
            取得可以代表集合的Id
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Collections.SettingCollectionBase`3.Dictionary">
            <summary>
            設定或取得用來儲存資料的內部字典
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Collections.SettingCollectionBase`3.DefaultValues">
            <summary>
            取得設定檔中所有設定的預設值(建立新個體)
            </summary>
        </member>
        <member name="M:TEC.Core.Settings.Collections.SettingCollectionBase`3.getDefaultValue(`0)">
            <summary>
            取得指定設定的預設值
            </summary>
            <param name="key">設定列舉</param>
            <returns></returns>
        </member>
        <member name="T:TEC.Core.Settings.Providers.XMLFileSettingProvider`4">
            <summary>
            檔案設定資料提供者(以 XML 模式序列化索引鍵值)，此提供者僅序列化設定檔集合中的索引鍵值，將忽略另外實作的屬性資訊。
            </summary>
            <typeparam name="TSettingCollection">實作<see cref="T:TEC.Core.Settings.ISettingCollection`3"/>以及<see cref="T:System.Xml.Serialization.IXmlSerializable"/>的型別</typeparam>
            <typeparam name="TKey">字典中之索引鍵的型別。</typeparam>
            <typeparam name="TValue"> 設定檔之值的型別。</typeparam>
            <typeparam name="TCollectionId">設定檔索引鍵之型別</typeparam>
            <seealso cref="T:TEC.Core.Settings.Collections.SettingCollectionBase`3"/>
        </member>
        <member name="M:TEC.Core.Settings.Providers.XMLFileSettingProvider`4.#ctor(System.IO.FileInfo)">
            <summary>
            初始化以 XML 為主的檔案設定資料提供者
            </summary>
            <param name="fileInfo">檔案的儲存位置</param>
            <exception cref="T:System.ArgumentNullException">當 <paramref name="fileInfo"/> 為 <c>null</c> 時擲出</exception>
            <exception cref="T:System.ArgumentNullException">當存檔目標 <paramref name="fileInfo"/> 的資料夾不存在時擲出</exception>
        </member>
        <member name="M:TEC.Core.Settings.Providers.XMLFileSettingProvider`4.load">
            <summary>
            從檔案讀取相關的設定檔
            </summary>
            <returns>設定檔資料</returns>
        </member>
        <member name="M:TEC.Core.Settings.Providers.XMLFileSettingProvider`4.save(`0)">
            <summary>
            儲存設定至檔案中
            </summary>
            <param name="settings">設定檔資料</param>
        </member>
        <member name="P:TEC.Core.Settings.Providers.XMLFileSettingProvider`4.FileInfo">
            <summary>
            取得存/讀檔目標路徑
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.XMLFileSettingProvider`4.SettingDirectoryPath">
            <summary>
            取得設定檔資料夾路徑資訊
            </summary>
        </member>
        <member name="T:TEC.Core.Settings.Providers.Resources.ApplicationSettingProvider">
            <summary>
              用於查詢當地語系化字串等的強類型資源類別。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.Resources.ApplicationSettingProvider.ResourceManager">
            <summary>
              傳回這個類別使用的快取的 ResourceManager 執行個體。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.Resources.ApplicationSettingProvider.Culture">
            <summary>
              覆寫目前執行緒的 CurrentUICulture 屬性，對象是所有
              使用這個強類型資源類別的資源查閱。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.Resources.ApplicationSettingProvider.IdCannotBeNull">
            <summary>
              查詢類似 When you are going to load/save the setting collection from/to ApplicationSettingProvider, make sure the Id property is not referenced to null. 的當地語系化字串。
            </summary>
        </member>
        <member name="T:TEC.Core.Settings.Providers.Resources.FileSettingProvider">
            <summary>
              用於查詢當地語系化字串等的強類型資源類別。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.Resources.FileSettingProvider.ResourceManager">
            <summary>
              傳回這個類別使用的快取的 ResourceManager 執行個體。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.Resources.FileSettingProvider.Culture">
            <summary>
              覆寫目前執行緒的 CurrentUICulture 屬性，對象是所有
              使用這個強類型資源類別的資源查閱。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.Resources.FileSettingProvider.ExtensionFormatError">
            <summary>
              查詢類似 The Extension value must starts with the character &apos;.&apos; and minimal length is 2. 的當地語系化字串。
            </summary>
        </member>
        <member name="T:TEC.Core.Settings.Providers.Resources.MemoryCacheSettingProvider">
            <summary>
              用於查詢當地語系化字串等的強類型資源類別。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.Resources.MemoryCacheSettingProvider.ResourceManager">
            <summary>
              傳回這個類別使用的快取的 ResourceManager 執行個體。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.Resources.MemoryCacheSettingProvider.Culture">
            <summary>
              覆寫目前執行緒的 CurrentUICulture 屬性，對象是所有
              使用這個強類型資源類別的資源查閱。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.Resources.MemoryCacheSettingProvider.CachedIsRemovedAfterSetting">
            <summary>
              查詢類似 The &quot;{0}&quot; is successfully generated, but it is removed right away after adding to memory cache, please check cache item policy(CacheItemPolicy)  to solve this problem. 的當地語系化字串。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.Resources.MemoryCacheSettingProvider.GenerateResultIsNull">
            <summary>
              查詢類似 The encapsulate method for generating &quot;{0}&quot;, &quot;{1}&quot; cannot return a null reference. 的當地語系化字串。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.Resources.MemoryCacheSettingProvider.SaveCannotBeCalledDirectly">
            <summary>
              查詢類似 The save method cannot be called directly, the save method is managed by this instance. 的當地語系化字串。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.Resources.MemoryCacheSettingProvider.SetUpdateCallbackWhenAutoGenerateIsTrue">
            <summary>
              查詢類似 When the &quot;{0}&quot; property is set to true, CacheItemPolicy.UpdateCallback must set to null. 的當地語系化字串。
            </summary>
        </member>
        <member name="T:TEC.Core.Settings.Providers.ApplicationSettingPool">
            <summary>
            將設定檔儲存於應用程式的管理區域
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.ApplicationSettingPool.ApplicationSettingDictionary">
            <summary>
            取得唯一的應用程式設定檔區域
            </summary>
        </member>
        <member name="T:TEC.Core.Settings.Providers.ApplicationSettingProvider`4">
            <summary>
            應用程式設定檔資料提供者
            </summary>
            <typeparam name="TSettingCollection">實作<see cref="T:TEC.Core.Settings.ISettingCollection`3"/>的型別</typeparam>
            <typeparam name="TKey">設定檔集合中之索引鍵的型別。</typeparam>
            <typeparam name="TValue"> 設定檔之值的型別。</typeparam>
            <typeparam name="TCollectionId">設定檔索引鍵之型別</typeparam>
        </member>
        <member name="M:TEC.Core.Settings.Providers.ApplicationSettingProvider`4.load">
            <summary>
            從應用程式快取讀取相關的設定檔
            </summary>
            <returns>設定檔資料</returns>
            <exception cref="T:System.ArgumentNullException">當設定檔的<see cref="P:TEC.Core.Settings.ISettingCollection`3.Id"/>回傳<c>null</c>時擲出</exception>
        </member>
        <member name="M:TEC.Core.Settings.Providers.ApplicationSettingProvider`4.save(`0)">
            <summary>
            儲存設定至應用程式快取中
            </summary>
            <param name="settings">設定檔資料</param>
            <exception cref="T:System.ArgumentNullException">當設定檔的<see cref="P:TEC.Core.Settings.ISettingCollection`3.Id"/>回傳<c>null</c>時擲出</exception>
        </member>
        <member name="T:TEC.Core.Settings.Providers.FileSettingProvider`4">
            <summary>
            檔案設定資料提供者(以 XML 模式序列化索引鍵值)，不建議使用，請改用<see cref="T:TEC.Core.Settings.Providers.XMLFileSettingProvider`4"/>。
            </summary>
            <typeparam name="TSettingCollection">實作<see cref="T:TEC.Core.Settings.ISettingCollection`3"/>以及<see cref="T:System.Xml.Serialization.IXmlSerializable"/>的型別</typeparam>
            <typeparam name="TKey">字典中之索引鍵的型別。</typeparam>
            <typeparam name="TValue"> 設定檔之值的型別。</typeparam>
            <typeparam name="TCollectionId">設定檔索引鍵之型別</typeparam>
            <seealso cref="T:TEC.Core.Settings.Collections.SettingCollectionBase`3"/>
        </member>
        <member name="M:TEC.Core.Settings.Providers.FileSettingProvider`4.#ctor(System.IO.FileInfo)">
            <summary>
            初始化檔案設定資料提供者
            </summary>
            <param name="fileInfo">檔案的儲存位置</param>
        </member>
        <member name="M:TEC.Core.Settings.Providers.FileSettingProvider`4.load">
            <summary>
            從檔案讀取相關的設定檔
            </summary>
            <returns>設定檔資料</returns>
        </member>
        <member name="M:TEC.Core.Settings.Providers.FileSettingProvider`4.save(`0)">
            <summary>
            儲存設定至檔案中
            </summary>
            <param name="settings">設定檔資料</param>
        </member>
        <member name="P:TEC.Core.Settings.Providers.FileSettingProvider`4.FileInfo">
            <summary>
            取得存/讀檔目標路徑
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.FileSettingProvider`4.ProviderName">
            <summary>
            設定提供者的名稱
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.FileSettingProvider`4.SettingDirectoryPath">
            <summary>
            取得設定檔路徑
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.FileSettingProvider`4.XmlFileSettingProvider">
            <summary>
            設定或取得 XML 設定檔提供者提供者
            </summary>
        </member>
        <member name="T:TEC.Core.Settings.Providers.ObjectCacheSettingProvider`4">
            <summary>
            實作<see cref="T:System.Runtime.Caching.ObjectCache"/>的快取設定檔提供者
            </summary>
            <typeparam name="TSettingCollection">實作<see cref="T:TEC.Core.Settings.ISettingCollection`3"/>的型別</typeparam>
            <typeparam name="TKey">字典中之索引鍵的型別。</typeparam>
            <typeparam name="TValue"> 設定檔之值的型別。</typeparam>
            <typeparam name="TCollectionId">設定檔索引鍵之型別</typeparam>
            <example>
            <para>SomeSettingCollection.cs</para>
            <code lang="C#">
            using System;
            namespace TEC.Core.TestConsole.Settings.Collections
            {
                /// &lt;summary&gt;
                /// 測試設定檔
                /// &lt;/summary&gt;
                public class SomeSettingCollection : TEC.Core.Settings.Collections.SettingCollectionBase&lt;SomeSettingEnum, object, string&gt;
                {
                    /// &lt;summary&gt;
                    /// 初始化測試設定檔集合的物件
                    /// &lt;/summary&gt;
                    public SomeSettingCollection()
                        : base("CollectionId") { }
                    public override object getDefaultValue(SomeSettingEnum key)
                    {
                        switch (key)
                        {
                            case SomeSettingEnum.Setting1:
                                return 0;
                            case SomeSettingEnum.Setting2:
                                return String.Empty;
                            default:
                                throw new NotImplementedException();
                        }
                    }
                }
                /// &lt;summary&gt;
                /// 測試設定檔列舉
                /// &lt;/summary&gt;
                public enum SomeSettingEnum
                {
                    /// &lt;summary&gt;
                    /// Setting1, System.Int32
                    /// &lt;/summary&gt;
                    Setting1,
                    /// &lt;summary&gt;
                    /// Setting1, System.String
                    /// &lt;/summary&gt;
                    Setting2
                }
            }
            </code>
            <para>SettingCollectionFactory.cs</para>
            <code lang="C#">
            using System;
            using TEC.Core.Settings.Providers;
            using TEC.Core.TestConsole.Settings.Collections;
            namespace TEC.Core.TestConsole.Settings
            {
                /// &lt;summary&gt;
                /// 用於產生設定檔的靜態類別
                /// &lt;/summary&gt;
                public static class SettingCollectionFactory
                {
                    static SettingCollectionFactory()
                    {
                        SettingCollectionFactory.CurrentObjectCacheSettingProviderInstance =
                            new ObjectCacheSettingProvider&lt;SomeSettingCollection, SomeSettingEnum, object, string&gt;(
                                System.Runtime.Caching.MemoryCache.Default,//以記憶體快取為主
                                "SomeSettingCollectionCachedKey",
                                () =&gt;
                                {
                                    SomeSettingCollection result = new SomeSettingCollection();
                                    //這裡是當沒有任何快取存在時，會執行到的部分
                                    result[SomeSettingEnum.Setting1] = 1;
                                    result[SomeSettingEnum.Setting2] = "SomeValue";
                                    return Tuple.Create&lt;System.Runtime.Caching.CacheItemPolicy, SomeSettingCollection&gt;(
                                         new System.Runtime.Caching.CacheItemPolicy()
                                         {
                                             AbsoluteExpiration = DateTimeOffset.Now.AddSeconds(10d),//10秒後清除
                                             Priority = System.Runtime.Caching.CacheItemPriority.Default
                                         }, result);
                                 //當下方參數設定為true時，不可以指定CacheItemPolicy.UpdateCallback的委派
                                },true);//過期後自動重新產生
                    }
                    /// &lt;summary&gt;
                    /// 取得設定檔資料
                    /// &lt;/summary&gt;
                    public static SomeSettingCollection SomeSettingCollection
                    {
                        get
                        {
                            return SettingCollectionFactory.CurrentObjectCacheSettingProviderInstance.load();
                        }
                    }
                    /// &lt;summary&gt;
                    /// 取得用於物件快取的設定檔提供者
                    /// &lt;/summary&gt;
                    public static ObjectCacheSettingProvider&lt;SomeSettingCollection, SomeSettingEnum, object, string&gt; CurrentObjectCacheSettingProviderInstance { private set; get; }
                }
            }
            </code>
            <para>
            SettingCollectionTest.cs
            </para>
            <code lang="C#">
            using TEC.Core.TestConsole.Settings.Collections;
            namespace TEC.Core.TestConsole.Settings
            {
                public class SettingCollectionTest
                {
                    public static void main()
                    {
                        SomeSettingCollection someSettingCollection = SettingCollectionFactory.SomeSettingCollection;
                        int value1 = (int)someSettingCollection[SomeSettingEnum.Setting1];//取得Setting1 的值並轉成整數
                        string value2 = someSettingCollection[SomeSettingEnum.Setting2].ToString();//取得Setting2 的值並轉換成字串
                        //取得被移除的設定檔
                        //SomeSettingCollection removedSomeSettingCollection = SettingCollectionFactory.CurrentObjectCacheSettingProviderInstance.flush();
                    }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:TEC.Core.Settings.Providers.ObjectCacheSettingProvider`4.#ctor(System.Runtime.Caching.ObjectCache,System.String,System.Func{System.Tuple{System.Runtime.Caching.CacheItemPolicy,`0}},System.Boolean)">
            <summary>
            初始化以指定記憶體內部快取作為設定檔提供者的物件
            </summary>
            <param name="objectCache">可實作記憶體內部快取的型別</param>
            <param name="cachedKeyName">用於快取的索引鍵</param>
            <param name="generateCollectionFunc">當沒有快取資料時，用於產生設定檔以及快取原則的封裝，傳回的兩個結果皆不可以為<c>null</c>參考</param>
            <param name="autoGenerateOnRemoving">是否要在快取被移除後自動於背景重新產生<typeparamref name="TSettingCollection"/></param>
            <exception cref="T:System.ArgumentNullException">當<paramref name="generateCollectionFunc"/>參數為<c>null</c>時發生</exception>
            <exception cref="T:System.ArgumentNullException">當<paramref name="cachedKeyName"/>參數為<c>null</c>或<c>String.Empty</c>時發生</exception>
            <exception cref="T:System.ArgumentNullException">當<paramref name="objectCache"/>參數為<c>null</c>時發生</exception>
        </member>
        <member name="M:TEC.Core.Settings.Providers.ObjectCacheSettingProvider`4.generateCollectionFuncAsync">
            <summary>
            非同步產生快取原則及其集合
            </summary>
            <returns>[快取原則,快取設定檔]</returns>
        </member>
        <member name="M:TEC.Core.Settings.Providers.ObjectCacheSettingProvider`4.load">
            <summary>
            從記憶體快取讀取相關的設定檔
            </summary>
            <returns>設定檔資料</returns>
            <exception cref="T:System.NullReferenceException">當產生<typeparamref name="TSettingCollection"/>封裝傳回<c>null</c>參考，或在設定至快取後隨即被移除會擲出此例外</exception>
        </member>
        <member name="M:TEC.Core.Settings.Providers.ObjectCacheSettingProvider`4.flush">
            <summary>
            強制從記憶體中清除此快取，下次重新讀取此設定檔時將會呼叫產生設定檔的方法封裝以重新建立快取項目
            </summary>
            <returns>若成功移除快取項目，則會傳回被移除的<typeparamref name="TSettingCollection"/></returns>
        </member>
        <member name="P:TEC.Core.Settings.Providers.ObjectCacheSettingProvider`4.ObjectCache">
            <summary>
            取得用於此提供者的快取資訊
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.ObjectCacheSettingProvider`4.CacheItemPolicy">
            <summary>
            取得快取項目的一組收回和期限詳細資料
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.ObjectCacheSettingProvider`4.CachedKeyName">
            <summary>
            取得用於快取的索引鍵
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.ObjectCacheSettingProvider`4.AutoGenerateOnRemoved">
            <summary>
            設定或取得是否要在快取被移除後自動於背景重新產生<typeparamref name="TSettingCollection"/>，當變更此值後，會在下一次重新產生快取集合時生效。
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.ObjectCacheSettingProvider`4.GenerateCollectionFunc">
            <summary>
            設定或取得產生設定檔的方法封裝
            </summary>
        </member>
        <member name="E:TEC.Core.Settings.Providers.ObjectCacheSettingProvider`4.OnCachingValueSaved">
            <summary>
            當設定檔集合成功儲存至快取後發生
            </summary>
        </member>
        <member name="T:TEC.Core.Settings.Providers.MemoryCacheSettingProvider`4">
            <summary>
            實作<see cref="T:System.Runtime.Caching.MemoryCache"/>的快取設定檔提供者
            </summary>
            <typeparam name="TSettingCollection">實作ISettingCollection的型別</typeparam>
            <typeparam name="TKey">字典中之索引鍵的型別。</typeparam>
            <typeparam name="TValue"> 設定檔之值的型別。</typeparam>
            <typeparam name="TCollectionId">設定檔索引鍵之型別</typeparam>
            <seealso cref="T:TEC.Core.Settings.Providers.ObjectCacheSettingProvider`4"/>
            <example>
            <para>SomeSettingCollection.cs</para>
            <code lang="C#">
            using System;
            namespace TEC.Core.TestConsole.Settings.Collections
            {
                /// &lt;summary&gt;
                /// 測試設定檔
                /// &lt;/summary&gt;
                public class SomeSettingCollection : TEC.Core.Settings.Collections.SettingCollectionBase&lt;SomeSettingEnum, object, string&gt;
                {
                    /// &lt;summary&gt;
                    /// 初始化測試設定檔集合的物件
                    /// &lt;/summary&gt;
                    public SomeSettingCollection()
                        : base("CollectionId") { }
                    public override object getDefaultValue(SomeSettingEnum key)
                    {
                        switch (key)
                        {
                            case SomeSettingEnum.Setting1:
                                return 0;
                            case SomeSettingEnum.Setting2:
                                return String.Empty;
                            default:
                                throw new NotImplementedException();
                        }
                    }
                }
                /// &lt;summary&gt;
                /// 測試設定檔列舉
                /// &lt;/summary&gt;
                public enum SomeSettingEnum
                {
                    /// &lt;summary&gt;
                    /// Setting1, System.Int32
                    /// &lt;/summary&gt;
                    Setting1,
                    /// &lt;summary&gt;
                    /// Setting1, System.String
                    /// &lt;/summary&gt;
                    Setting2
                }
            }
            </code>
            <para>SettingCollectionFactory.cs</para>
            <code lang="C#">
            using System;
            using TEC.Core.Settings.Providers;
            using TEC.Core.TestConsole.Settings.Collections;
            namespace TEC.Core.TestConsole.Settings
            {
                /// &lt;summary&gt;
                /// 用於產生設定檔的靜態類別
                /// &lt;/summary&gt;
                public static class SettingCollectionFactory
                {
                    static SettingCollectionFactory()
                    {
                        SettingCollectionFactory.CurrentMemoryCacheSettingProviderInstance =
                            new MemoryCacheSettingProvider&lt;SomeSettingCollection, SomeSettingEnum, object, string&gt;(
                                "SomeSettingCollectionCachedKey",
                                () =&gt;
                                {
                                    SomeSettingCollection result = new SomeSettingCollection();
                                    //這裡是當沒有任何快取存在時，會執行到的部分
                                    result[SomeSettingEnum.Setting1] = 1;
                                    result[SomeSettingEnum.Setting2] = "SomeValue";
                                    return Tuple.Create&lt;System.Runtime.Caching.CacheItemPolicy, SomeSettingCollection&gt;(
                                         new System.Runtime.Caching.CacheItemPolicy()
                                         {
                                             AbsoluteExpiration = DateTimeOffset.Now.AddSeconds(10d),//10秒後清除
                                             Priority = System.Runtime.Caching.CacheItemPriority.Default
                                         }, result);
                                 //當下方參數設定為true時，不可以指定CacheItemPolicy.UpdateCallback的委派
                                },true);//過期後自動重新產生
                    }
                    /// &lt;summary&gt;
                    /// 取得設定檔資料
                    /// &lt;/summary&gt;
                    public static SomeSettingCollection SomeSettingCollection
                    {
                        get
                        {
                            return SettingCollectionFactory.CurrentMemoryCacheSettingProviderInstance.load();
                        }
                    }
                    /// &lt;summary&gt;
                    /// 取得用於記憶體快取的設定檔提供者
                    /// &lt;/summary&gt;
                    public static MemoryCacheSettingProvider&lt;SomeSettingCollection, SomeSettingEnum, object, string&gt; CurrentMemoryCacheSettingProviderInstance { private set; get; }
                }
            }
            </code>
            <para>
            SettingCollectionTest.cs
            </para>
            <code lang="C#">
            using TEC.Core.TestConsole.Settings.Collections;
            namespace TEC.Core.TestConsole.Settings
            {
                public class SettingCollectionTest
                {
                    public static void main()
                    {
                        SomeSettingCollection someSettingCollection = SettingCollectionFactory.SomeSettingCollection;
                        int value1 = (int)someSettingCollection[SomeSettingEnum.Setting1];//取得Setting1 的值並轉成整數
                        string value2 = someSettingCollection[SomeSettingEnum.Setting2].ToString();//取得Setting2 的值並轉換成字串
                        //取得被移除的設定檔
                        //SomeSettingCollection removedSomeSettingCollection = SettingCollectionFactory.CurrentMemoryCacheSettingProviderInstance.flush();
                    }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:TEC.Core.Settings.Providers.MemoryCacheSettingProvider`4.#ctor(System.Runtime.Caching.MemoryCache,System.String,System.Func{System.Tuple{System.Runtime.Caching.CacheItemPolicy,`0}},System.Boolean)">
            <summary>
            初始化以指定記憶體內部快取作為設定檔提供者的物件
            </summary>
            <param name="memoryCache">可實作記憶體內部快取的型別</param>
            <param name="cachedKeyName">用於快取的索引鍵</param>
            <param name="generateCollectionFunc">當沒有快取資料時，用於產生設定檔以及快取原則的封裝，傳回的兩個結果皆不可以為<c>null</c>參考</param>
            <param name="autoGenerateOnRemoving">是否要在快取被移除後自動於背景重新產生<typeparamref name="TSettingCollection"/></param>
            <exception cref="T:System.ArgumentNullException">當<paramref name="generateCollectionFunc"/>參數為<c>null</c>時發生</exception>
            <exception cref="T:System.ArgumentNullException">當<paramref name="cachedKeyName"/>參數為<c>null</c>或<c>String.Empty</c>時發生</exception>
            <exception cref="T:System.ArgumentNullException">當<paramref name="memoryCache"/>參數為<c>null</c>時發生</exception>
        </member>
        <member name="M:TEC.Core.Settings.Providers.MemoryCacheSettingProvider`4.#ctor(System.String,System.Func{System.Tuple{System.Runtime.Caching.CacheItemPolicy,`0}},System.Boolean)">
            <summary>
            初始化以<see cref="P:System.Runtime.Caching.MemoryCache.Default"/>為設定檔提供者的物件
            </summary>
            <param name="cachedKeyName">用於快取的索引鍵</param>
            <param name="generateCollectionFunc">當沒有快取資料時，用於產生設定檔以及快取原則的封裝，傳回的兩個結果皆不可以為<c>null</c>參考</param>
            <param name="autoGenerateOnRemoving">是否要在快取被移除後自動於背景重新產生<typeparamref name="TSettingCollection"/></param>
            <exception cref="T:System.ArgumentNullException">當<paramref name="generateCollectionFunc"/>參數為<c>null</c>時發生</exception>
            <exception cref="T:System.ArgumentNullException">當<paramref name="cachedKeyName"/>參數為<c>null</c>或<c>String.Empty</c>時發生</exception>
        </member>
        <member name="T:TEC.Core.Settings.Providers.SettingCollectionCachingSavedEventArgs`1">
            <summary>
            當設定檔成功儲存至快取時引發事件的參數
            </summary>
            <typeparam name="TSettingCollection">設定檔集合泛型</typeparam>
        </member>
        <member name="M:TEC.Core.Settings.Providers.SettingCollectionCachingSavedEventArgs`1.#ctor(`0,System.Runtime.Caching.ObjectCache)">
            <summary>
            初始化成功儲存設定檔至物件快取的事件參數
            </summary>
            <param name="settingCollection">已儲存的設定檔集合</param>
            <param name="objectCache">相關的快取</param>
        </member>
        <member name="P:TEC.Core.Settings.Providers.SettingCollectionCachingSavedEventArgs`1.SettingCollection">
            <summary>
            取得已儲存至快取的設定檔集合
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.Providers.SettingCollectionCachingSavedEventArgs`1.ObjectCache">
            <summary>
            取得儲存快取的物件快取
            </summary>
        </member>
        <member name="T:TEC.Core.Settings.SetCacheFailedException">
            <summary>
            當設定快取發生錯誤時的例外狀況
            </summary>
        </member>
        <member name="M:TEC.Core.Settings.SetCacheFailedException.#ctor(System.Object,System.Runtime.Caching.CacheItemPolicy,System.String,System.Exception)">
            <summary>
            使用指定的錯誤訊息和造成這個例外狀況原因的內部例外參考，初始化設定快取發生錯誤時的例外狀況
            </summary>
            <param name="cacheValue">快取失敗的值</param>
            <param name="cacheItemPolicy">快取失敗的快取原則</param>
            <param name="errorMessage">描述錯誤的訊息</param>
            <param name="innerException">目前例外狀況原因的例外狀況，如果沒有指定內部例外狀況，則為 Null 參考 (Visual Basic 中的 Nothing)</param>
        </member>
        <member name="M:TEC.Core.Settings.SetCacheFailedException.#ctor(System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)">
            <summary>
            使用指定的錯誤訊息，初始化設定快取發生錯誤時的例外狀況
            </summary>
            <param name="cacheValue">快取失敗的值</param>
            <param name="cacheItemPolicy">快取失敗的快取原則</param>
            <param name="errorMessage">描述錯誤的訊息</param>
        </member>
        <member name="M:TEC.Core.Settings.SetCacheFailedException.#ctor(System.Object,System.Runtime.Caching.CacheItemPolicy)">
            <summary>
            初始化設定快取發生錯誤時的例外狀況
            </summary>
            <param name="cacheValue">快取失敗的值</param>
            <param name="cacheItemPolicy">快取失敗的快取原則</param>
        </member>
        <member name="P:TEC.Core.Settings.SetCacheFailedException.CacheValue">
            <summary>
            取得發生快取失敗的值
            </summary>
        </member>
        <member name="P:TEC.Core.Settings.SetCacheFailedException.CacheItemPolicy">
            <summary>
            取得發生快取失敗的快取原則
            </summary>
        </member>
        <member name="T:TEC.Core.Text.Format.OrderedFormatMemberAttribute">
            <summary>
            指定其屬性為依順序格化的成員之一
            </summary>
            <seealso cref="T:TEC.Core.Text.Format.OrderedMemberFormatter"/>    
        </member>
        <member name="M:TEC.Core.Text.Format.OrderedFormatMemberAttribute.#ctor(System.UInt32)">
            <summary>
            初始化格式化成員之屬性
            </summary>
            <param name="order">要被序列化的順序</param>
        </member>
        <member name="P:TEC.Core.Text.Format.OrderedFormatMemberAttribute.Order">
            <summary>
            設定或取得順位，數值越小為輸出在越前面。
            </summary>
        </member>
        <member name="T:TEC.Core.Text.Format.OrderedMemberCSVFormatter">
            <summary>
            將指定物件中被標記為<see cref="T:TEC.Core.Text.Format.OrderedFormatMemberAttribute"/>之屬性格式化文字至CSV格式之類別
            </summary>
            <seealso cref="T:TEC.Core.Text.Format.OrderedFormatMemberAttribute"/>
        </member>
        <member name="M:TEC.Core.Text.Format.OrderedMemberCSVFormatter.serializeAttribute``2(System.Func{``1,System.String},System.String)">
            <summary>
            以<paramref name="connector"/>字串連接指定<typeparamref name="TSourceType"/>型別的中同時被標記為
            <see cref="T:TEC.Core.Text.Format.OrderedFormatMemberAttribute"/>以及<typeparamref name="TAttribute"/>之每個屬性。
            </summary>
            <typeparam name="TSourceType">要序列化為字串的型別</typeparam>
            <typeparam name="TAttribute">當自<typeparamref name="TSourceType"/>型別中取得序列化的屬性時，用於取得其字串結果的屬性宣告</typeparam>
            <param name="attributeStringFunc">輸入指定的<typeparamref name="TAttribute"/>執行個體，取得字串結果的方法封裝</param>
            <param name="connector">用於連接每個屬性字串結果的字串</param>
            <returns>傳回序列化之後的結果</returns>
            <exception cref="T:System.ArgumentException">當屬性被標記<see cref="T:TEC.Core.Text.Format.OrderedFormatMemberAttribute"/>但卻沒有標記<typeparamref name="TAttribute"/>時擲出</exception>
            <example>
            <para>
            BankEODToCSV.cs
            </para>
            <code lang="C#">
            /// &lt;summary&gt;
            /// 描述銀行對帳單的一筆資料
            /// &lt;/summary&gt;
            public class BankEODToCSV
            {
                /// &lt;summary&gt;
                /// 設定或取得交易代號
                /// &lt;/summary&gt;
                [OrderedFormatMember(0), DisplayName("交易代號")]
                public string TransactionId { set; get; }
                /// &lt;summary&gt;
                /// 設定或取得銀行代碼
                /// &lt;/summary&gt;
                [OrderedFormatMember(1), DisplayName("銀行代碼")]
                public string BankCode { set; get; }
                /// &lt;summary&gt;
                /// 設定或取得應付帳款
                /// &lt;/summary&gt;
                [OrderedFormatMember(2), DisplayName("應付帳款")]
                public decimal AccountPayable { set; get; }
                /// &lt;summary&gt;
                /// 設定或取得應收帳款
                /// &lt;/summary&gt;
                [OrderedFormatMember(3), DisplayName("應收帳款")]
                public decimal AccountReceivable { set; get; }
                /// &lt;summary&gt;
                /// 設定或取得狀態代號
                /// &lt;/summary&gt;
                [OrderedFormatMember(4), DisplayName("狀態代號")]
                public string StatusCode { set; get; }
            }
            </code>
            <para>
            Program.cs
            </para>
            <code lang="C#">
            public static void main()
            {
                //using using TEC.Core.Text.Format;
                string firstLine = OrderedMemberCSVFormatter.serializeAttribute&lt;BankEODToCSV, System.ComponentModel.DisplayNameAttribute&gt;(t =&gt; t.DisplayName, ",");
                BankEODToCSV bankEODToCSV = new BankEODToCSV()
                {
                    AccountPayable = 500m,
                    AccountReceivable = 520m,
                    BankCode = "004",
                    StatusCode = "000",
                    TransactionId = Guid.NewGuid().ToString("D")
                };
                //單筆序列化CSV格式
                string singleRecordResult = OrderedMemberCSVFormatter.serializeObject(bankEODToCSV, ",", (propertyInfo, value) =&gt;
                {
                    if (propertyInfo.PropertyType == typeof(DateTime))
                    {
                        //force to specific format
                        return ((DateTime)value).ToString("yyyy/MM/dd HH:mm:ss");
                    }
                    if (value == null)
                    {
                        return String.Empty;
                    }
                    //default to object string 
                    return value.ToString();
                });
                //多筆匯出CSV
                string multiRecordResult = firstLine + Environment.NewLine + String.Join(Environment.NewLine,
                    new List&lt;BankEODToCSV&gt;() {
                        new BankEODToCSV()
                        {
                            AccountPayable = 500m,
                            AccountReceivable = 520m,
                            BankCode = "004",
                            StatusCode = "000",
                            TransactionId = Guid.NewGuid().ToString("D")
                        } 
                    }.Select(t =&gt; OrderedMemberCSVFormatter.serializeObject(t, ",", (propertyInfo, value) =&gt;
                    {
                        if (propertyInfo.PropertyType == typeof(DateTime))
                        {
                            //force to specific format
                            return ((DateTime)value).ToString("yyyy/MM/dd HH:mm:ss");
                        }
                        if (value == null)
                        {
                            return String.Empty;
                        }
                        //default to object string 
                        return value.ToString();
                    })));
            }
            </code>
            </example>
            <seealso cref="M:TEC.Core.Text.Format.OrderedMemberCSVFormatter.serializeObject(System.Object,System.String,System.Func{System.Reflection.PropertyInfo,System.Object,System.String})"/>
        </member>
        <member name="M:TEC.Core.Text.Format.OrderedMemberCSVFormatter.serializeObject(System.Object,System.String,System.Func{System.Reflection.PropertyInfo,System.Object,System.String})">
            <summary>
            以<paramref name="connector"/>字串連接指定<paramref name="formattableObject"/>物件中被標記為
            <see cref="T:TEC.Core.Text.Format.OrderedFormatMemberAttribute"/>的屬性值
            </summary>
            <param name="formattableObject">要序列化的物件</param>
            <param name="connector">每個值所要使用的連接字串</param>
            <param name="stringFormatterFunc">輸入指定屬性的型別與值，傳回可以表示該值的字串</param>
            <returns>傳回序列化後的結果</returns>
            <example>
            <para>
            BankEODToCSV.cs
            </para>
            <code lang="C#">
            /// &lt;summary&gt;
            /// 描述銀行對帳單的一筆資料
            /// &lt;/summary&gt;
            public class BankEODToCSV
            {
                /// &lt;summary&gt;
                /// 設定或取得交易代號
                /// &lt;/summary&gt;
                [OrderedFormatMember(0), DisplayName("交易代號")]
                public string TransactionId { set; get; }
                /// &lt;summary&gt;
                /// 設定或取得銀行代碼
                /// &lt;/summary&gt;
                [OrderedFormatMember(1), DisplayName("銀行代碼")]
                public string BankCode { set; get; }
                /// &lt;summary&gt;
                /// 設定或取得應付帳款
                /// &lt;/summary&gt;
                [OrderedFormatMember(2), DisplayName("應付帳款")]
                public decimal AccountPayable { set; get; }
                /// &lt;summary&gt;
                /// 設定或取得應收帳款
                /// &lt;/summary&gt;
                [OrderedFormatMember(3), DisplayName("應收帳款")]
                public decimal AccountReceivable { set; get; }
                /// &lt;summary&gt;
                /// 設定或取得狀態代號
                /// &lt;/summary&gt;
                [OrderedFormatMember(4), DisplayName("狀態代號")]
                public string StatusCode { set; get; }
            }
            </code>
            <para>
            Program.cs
            </para>
            <code lang="C#">
            public static void main()
            {
                //using using TEC.Core.Text.Format;
                string firstLine = OrderedMemberCSVFormatter.serializeAttribute&lt;BankEODToCSV, System.ComponentModel.DisplayNameAttribute&gt;(t =&gt; t.DisplayName, ",");
                BankEODToCSV bankEODToCSV = new BankEODToCSV()
                {
                    AccountPayable = 500m,
                    AccountReceivable = 520m,
                    BankCode = "004",
                    StatusCode = "000",
                    TransactionId = Guid.NewGuid().ToString("D")
                };
                //單筆序列化CSV格式
                string singleRecordResult = OrderedMemberCSVFormatter.serializeObject(bankEODToCSV, ",", (propertyInfo, value) =&gt;
                {
                    if (propertyInfo.PropertyType == typeof(DateTime))
                    {
                        //force to specific format
                        return ((DateTime)value).ToString("yyyy/MM/dd HH:mm:ss");
                    }
                    if (value == null)
                    {
                        return String.Empty;
                    }
                    //default to object string 
                    return value.ToString();
                });
                //多筆匯出CSV
                string multiRecordResult = firstLine + Environment.NewLine + String.Join(Environment.NewLine,
                    new List&lt;BankEODToCSV&gt;() {
                        new BankEODToCSV()
                        {
                            AccountPayable = 500m,
                            AccountReceivable = 520m,
                            BankCode = "004",
                            StatusCode = "000",
                            TransactionId = Guid.NewGuid().ToString("D")
                        } 
                    }.Select(t =&gt; OrderedMemberCSVFormatter.serializeObject(t, ",", (propertyInfo, value) =&gt;
                    {
                        if (propertyInfo.PropertyType == typeof(DateTime))
                        {
                            //force to specific format
                            return ((DateTime)value).ToString("yyyy/MM/dd HH:mm:ss");
                        }
                        if (value == null)
                        {
                            return String.Empty;
                        }
                        //default to object string 
                        return value.ToString();
                    })));
            }
            </code>
            </example>
            <seealso cref="M:TEC.Core.Text.Format.OrderedMemberCSVFormatter.serializeAttribute``2(System.Func{``1,System.String},System.String)"/>
        </member>
        <member name="T:TEC.Core.Text.Format.OrderedMemberFormatter">
            <summary>
            將指定物件中被標記為<see cref="T:TEC.Core.Text.Format.OrderedFormatMemberAttribute"/>之屬性格式化文字之類別
            </summary>
            <seealso cref="T:TEC.Core.Text.Format.OrderedFormatMemberAttribute"/>
            <seealso cref="T:TEC.Core.Text.Format.PadingStringFormatAttribute"/>
            <example>
            <para>
            BankEOD.cs
            </para>
            <code lang="C#">
            &lt;summary&gt;
            描述銀行對帳單的一筆資料
            &lt;/summary&gt;
            public class BankEOD
            {
                /// &lt; summary&gt;
                /// 設定或取得交易代號
                /// &lt; /summary&gt;
                [OrderedFormatMember(0), PadingStringFormat(' ', 30, PadingDirection.PadRight)]
                public string TransactionId { set; get; }
                /// &lt; summary&gt;
                /// 設定或取得銀行代碼
                /// &lt; /summary&gt;
                [OrderedFormatMember(1), PadingStringFormat(' ', 9, CaddingDirection.PadRight)]
                public string BankCode { set; get; }
                /// &lt; summary&gt;
                /// 設定或取得應付帳款
                /// &lt; /summary&gt;
                [OrderedFormatMember(2), PadingStringFormat('0', 20, PadingDirection.PadLeft)]
                public string AccountPayable { set; get; }
                /// &lt; summary&gt;
                /// 設定或取得應收帳款
                /// &lt; /summary&gt;
                [OrderedFormatMember(3), PadingStringFormat('0', 20, PadingDirection.PadLeft)]
                public string AccountReceivable { set; get; }
                /// &lt; summary&gt;
                /// 設定或取得狀態代號
                /// &lt; /summary&gt;
                [OrderedFormatMember(4), PadingStringFormat(' ', 10, PadingDirection.PadLeft)]
                public string StatusCode { set; get; }
            }
            </code>
            <para>
            Program.cs
            </para>
            <code lang="C#">
            BankEOD bankEOD1 = new BankEOD()
            {
                AccountPayable="300.2",
                AccountReceivable="150.22",
                BankCode="TEC",
                StatusCode="A001",
                TransactionId="TRA20140101120000-0012"
            };
            string serializeResult = OrderedMemberFormatter.serializeObject(bankEOD1);
            //serializeResult : "TRA20140101120000-0012        TEC      000000000000000300.200000000000000150.22      A001"
            BankEOD bankEOD2 = OrderedMemberFormatter.deserializeObject&lt;BankEOD&gt;("TRA20140101120000-0013        TEC      000000000000000101.1000000000000000088.1      A001", Encoding.Default);
            </code>
            </example>
        </member>
        <member name="M:TEC.Core.Text.Format.OrderedMemberFormatter.serializeObject(System.Object)">
            <summary>
            從指定的物件中取得所有已排序的格式化字串
            </summary>
            <param name="formattableObject">要取得格式化字串的物件</param>
            <seealso cref="T:TEC.Core.Text.Format.OrderedFormatMemberAttribute"/>
            <seealso cref="T:TEC.Core.Text.Format.PadingStringFormatAttribute"/>
            <returns>傳回的結果</returns>
        </member>
        <member name="M:TEC.Core.Text.Format.OrderedMemberFormatter.serializeObjectToDictionary(System.Object)">
            <summary>
            從指定的物件中取得所有已排序的格式化字串
            </summary>
            <param name="formattableObject">要取得格式化字串的物件</param>
            <seealso cref="T:TEC.Core.Text.Format.OrderedFormatMemberAttribute"/>
            <seealso cref="T:TEC.Core.Text.Format.PadingStringFormatAttribute"/>
            <returns>傳回的結果</returns>
        </member>
        <member name="M:TEC.Core.Text.Format.OrderedMemberFormatter.serializeObjectToDictionaryAsync(System.Object)">
            <summary>
            非同步從指定的物件中取得所有已排序的格式化字串
            </summary>
            <param name="formattableObject">要取得格式化字串的物件</param>
            <returns>傳回的結果</returns>
            <seealso cref="T:TEC.Core.Text.Format.OrderedFormatMemberAttribute"/>
            <seealso cref="T:TEC.Core.Text.Format.PadingStringFormatAttribute"/>
        </member>
        <member name="M:TEC.Core.Text.Format.OrderedMemberFormatter.deserializeObject``1(System.String,System.Text.Encoding)">
            <summary>
            分解字串以取得其物件
            </summary>
            <typeparam name="T">要取得的物件類型</typeparam>
            <param name="formattedString">已經格式化後的字串</param>
            <param name="encoding">指定字串的編碼方式</param>
            <returns>指定型別的物件</returns>
            <exception cref="T:System.ArgumentException">分割文字時有任何例外都將以此例外擲出</exception>
            <seealso cref="T:TEC.Core.Text.Format.PadingStringFormatAttribute"/>
            <seealso cref="T:TEC.Core.Text.Format.OrderedFormatMemberAttribute"/>
            <remarks>
            注意: 當任何屬性被標記<see cref="T:TEC.Core.Text.Format.OrderedFormatMemberAttribute"/>時，也同時必須被標記為<see cref="T:TEC.Core.Text.Format.PadingStringFormatAttribute"/>。
            </remarks>
        </member>
        <member name="M:TEC.Core.Text.Format.OrderedMemberFormatter.deserializeObjectAsync``1(System.String,System.Text.Encoding)">
            <summary>
            非同步分解字串以取得其物件
            </summary>
            <typeparam name="T">要取得的物件類型，要輸入的屬性型別必須為<see cref="T:System.String"/></typeparam>
            <param name="formattedString">已經格式化後的字串</param>
            <param name="encoding">指定字串的編碼方式</param>
            <returns>指定型別的物件</returns>
            <seealso cref="T:TEC.Core.Text.Format.OrderedFormatMemberAttribute"/>
            <seealso cref="T:TEC.Core.Text.Format.PadingStringFormatAttribute"/>
            <exception cref="T:System.ArgumentException">分割文字時有任何例外都將以此例外擲出</exception>
            <remarks>
            注意: 當任何屬性被標記<see cref="T:TEC.Core.Text.Format.OrderedFormatMemberAttribute"/>時，也同時必須被標記為<see cref="T:TEC.Core.Text.Format.PadingStringFormatAttribute"/>。
            </remarks>
        </member>
        <member name="T:TEC.Core.Text.Format.PadingDirection">
            <summary>
            填充方向之列舉
            </summary>
        </member>
        <member name="F:TEC.Core.Text.Format.PadingDirection.PadRight">
            <summary>
            填充右方
            </summary>
        </member>
        <member name="F:TEC.Core.Text.Format.PadingDirection.PadLeft">
            <summary>
            填充左方
            </summary>
        </member>
        <member name="T:TEC.Core.Text.Format.PadingStringFormatAttribute">
            <summary>
            用於將字串依照指定字元將其格式化為指定長度之屬性，此類別無法被繼承。
            </summary>
            <seealso cref="T:TEC.Core.Text.Format.OrderedMemberFormatter"/>    
        </member>
        <member name="M:TEC.Core.Text.Format.PadingStringFormatAttribute.#ctor(System.Char,System.Int32,TEC.Core.Text.Format.PadingDirection)">
            <summary>
            建立格式化字串之物件
            </summary>
            <param name="padingCharacter">要填補之字元</param>
            <param name="length">填補之後的長度(半形字元數)</param>
            <param name="padingDirection">方向</param>
        </member>
        <member name="M:TEC.Core.Text.Format.PadingStringFormatAttribute.getFormattedString(System.Object,System.ComponentModel.PropertyDescriptor)">
            <summary>
            取得已格式化後的字串，若欄位值為<c lang="C#">null</c>時，將視為<see cref="F:System.String.Empty"/>
            </summary>
            <param name="instance">要取得的執行個體</param>
            <param name="property">要取得其值的屬性</param>
            <returns>格式化後的字串</returns>
            <exception cref="T:System.NullReferenceException">當該物件中沒有任何屬性被標記成<see cref="T:TEC.Core.Text.Format.PadingStringFormatAttribute"/>時擲出</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">當輸入的字串長度超過<see cref="P:TEC.Core.Text.Format.PadingStringFormatAttribute.Length"/>時擲出</exception>
            
        </member>
        <member name="P:TEC.Core.Text.Format.PadingStringFormatAttribute.Length">
            <summary>
            取得長度(半形字元數)
            </summary>
        </member>
        <member name="P:TEC.Core.Text.Format.PadingStringFormatAttribute.PadingDirection">
            <summary>
            取得填補字元之方式
            </summary>
        </member>
        <member name="P:TEC.Core.Text.Format.PadingStringFormatAttribute.PadingCharacter">
            <summary>
            取得填充字元
            </summary>
        </member>
        <member name="T:TEC.Core.Text.Format.Resources.OrderedMemberCSVFormatter">
            <summary>
              用於查詢當地語系化字串等的強類型資源類別。
            </summary>
        </member>
        <member name="P:TEC.Core.Text.Format.Resources.OrderedMemberCSVFormatter.ResourceManager">
            <summary>
              傳回這個類別使用的快取的 ResourceManager 執行個體。
            </summary>
        </member>
        <member name="P:TEC.Core.Text.Format.Resources.OrderedMemberCSVFormatter.Culture">
            <summary>
              覆寫目前執行緒的 CurrentUICulture 屬性，對象是所有
              使用這個強類型資源類別的資源查閱。
            </summary>
        </member>
        <member name="P:TEC.Core.Text.Format.Resources.OrderedMemberCSVFormatter.TAttributeNotExists">
            <summary>
              查詢類似 You have to mark {0} to the {1} property which is marked with {2}. 的當地語系化字串。
            </summary>
        </member>
        <member name="T:TEC.Core.Text.Format.Resources.OrderedMemberFormatter">
            <summary>
              用於查詢當地語系化字串等的強類型資源類別。
            </summary>
        </member>
        <member name="P:TEC.Core.Text.Format.Resources.OrderedMemberFormatter.ResourceManager">
            <summary>
              傳回這個類別使用的快取的 ResourceManager 執行個體。
            </summary>
        </member>
        <member name="P:TEC.Core.Text.Format.Resources.OrderedMemberFormatter.Culture">
            <summary>
              覆寫目前執行緒的 CurrentUICulture 屬性，對象是所有
              使用這個強類型資源類別的資源查閱。
            </summary>
        </member>
        <member name="P:TEC.Core.Text.Format.Resources.OrderedMemberFormatter.PadingStringFormatAttributeNotExists">
            <summary>
              查詢類似 You have to mark {0} to the {1} property which is marked with {2}. 的當地語系化字串。
            </summary>
        </member>
        <member name="T:TEC.Core.Text.Format.Resources.PadingStringFormatAttribute">
            <summary>
              用於查詢當地語系化字串等的強類型資源類別。
            </summary>
        </member>
        <member name="P:TEC.Core.Text.Format.Resources.PadingStringFormatAttribute.ResourceManager">
            <summary>
              傳回這個類別使用的快取的 ResourceManager 執行個體。
            </summary>
        </member>
        <member name="P:TEC.Core.Text.Format.Resources.PadingStringFormatAttribute.Culture">
            <summary>
              覆寫目前執行緒的 CurrentUICulture 屬性，對象是所有
              使用這個強類型資源類別的資源查閱。
            </summary>
        </member>
        <member name="P:TEC.Core.Text.Format.Resources.PadingStringFormatAttribute.CannotFindPadingStringFormatAttribute">
            <summary>
              查詢類似 Cannot find any property with &quot;{0}&quot; declared for current instance. 的當地語系化字串。
            </summary>
        </member>
        <member name="P:TEC.Core.Text.Format.Resources.PadingStringFormatAttribute.StringLengthLargerThanTotalLength">
            <summary>
              查詢類似 The string length of the value &quot;{0}&quot; is larger than max length {1}. 的當地語系化字串。
            </summary>
        </member>
        <member name="T:TEC.Core.Text.StringExtension">
            <summary>
            字串的擴充靜態類別
            </summary>
        </member>
        <member name="M:TEC.Core.Text.StringExtension.subStringByByte(System.String,System.UInt32)">
            <summary>
            由系統預設<see cref="P:System.Text.Encoding.Default"/>編碼方式擷取由索引位置0起始的<paramref name="bytesCount"/>位元組單位的字串長度
            </summary>
            <param name="originalString">要擷取的字串</param>
            <param name="bytesCount">擷取的字串長度(以位元組為單位)</param>
            <returns>擷取後的字串</returns>
            <example>
            <code lang="C#">
            //using TEC.Core.Text
            string str8 = "原始文字".subStringByByte(4);//原始(系統預設編碼為 Big5)
            string str9 = "原始文字".subStringByByte(5);//原始(系統預設編碼為 Big5)
            string str10 = "原始文字".subStringByByte(6);//原始文(系統預設編碼為 Big5)
            </code>
            </example>
        </member>
        <member name="M:TEC.Core.Text.StringExtension.subStringByByte(System.String,System.UInt32,System.String)">
            <summary>
            由系統預設<see cref="P:System.Text.Encoding.Default"/>編碼方式擷取由索引位置0起始的<paramref name="bytesCount"/>位元組單位的字串長度
            </summary>
            <param name="originalString">要擷取的字串</param>
            <param name="postString">當<paramref name="originalString"/>超過輸入的位元組數時，將在擷取後的文字後方加上此字串</param>
            <param name="bytesCount">擷取的字串長度(以位元組為單位)</param>
            <returns>擷取後的字串</returns>
            <example>
            <code lang="C#">
            //using TEC.Core.Text
            string str11 = "原始文字".subStringByByte(4, "...");//原始...(系統預設編碼為 Big5)
            string str12 = "原始文字".subStringByByte(5, "...");//原始...(系統預設編碼為 Big5)
            string str13 = "原始文字".subStringByByte(6, "...");//原始文...(系統預設編碼為 Big5)
            string str14 = "原始文字".subStringByByte(10, "...");//原始文字(系統預設編碼為 Big5)
            </code>
            </example>
        </member>
    </members>
</doc>
