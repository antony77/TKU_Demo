<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TEC.Core.Scheduler</name>
    </assembly>
    <members>
        <member name="T:TEC.Core.Scheduler.Timers.ITimerEvent">
            <summary>
            描述類別可以藉由<see cref="T:TEC.Core.Scheduler.Timers.TimerManager"/>建立排程所需的事件介面。
            </summary>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.ITimerEvent.execute">
            <summary>
            執行排定的動作內容
            </summary>
        </member>
        <member name="T:TEC.Core.Scheduler.Timers.NextTimeEvaluationType">
            <summary>
            指定用於預估下次執行排程時間的依據
            </summary>
        </member>
        <member name="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.ExecutionEndTime">
            <summary>
            以每次執行完成時間為基礎
            </summary>
        </member>
        <member name="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.StartUpTime">
            <summary>
            以第一次執行時間為基礎
            </summary>
        </member>
        <member name="T:TEC.Core.Scheduler.Timers.Resource.ThreadingTimerStorage">
            <summary>
              用於查詢當地語系化字串等的強類型資源類別。
            </summary>
        </member>
        <member name="P:TEC.Core.Scheduler.Timers.Resource.ThreadingTimerStorage.ResourceManager">
            <summary>
              傳回這個類別使用的快取的 ResourceManager 執行個體。
            </summary>
        </member>
        <member name="P:TEC.Core.Scheduler.Timers.Resource.ThreadingTimerStorage.Culture">
            <summary>
              覆寫目前執行緒的 CurrentUICulture 屬性，對象是所有
              使用這個強類型資源類別的資源查閱。
            </summary>
        </member>
        <member name="P:TEC.Core.Scheduler.Timers.Resource.ThreadingTimerStorage.TimerStatusNotSupportedOnStartException">
            <summary>
              查詢類似 You cannot start timer when TimerStatus is not &quot;{0}&quot;. 的當地語系化字串。
            </summary>
        </member>
        <member name="T:TEC.Core.Scheduler.Timers.Resource.TimersTimerStorage">
            <summary>
              用於查詢當地語系化字串等的強類型資源類別。
            </summary>
        </member>
        <member name="P:TEC.Core.Scheduler.Timers.Resource.TimersTimerStorage.ResourceManager">
            <summary>
              傳回這個類別使用的快取的 ResourceManager 執行個體。
            </summary>
        </member>
        <member name="P:TEC.Core.Scheduler.Timers.Resource.TimersTimerStorage.Culture">
            <summary>
              覆寫目前執行緒的 CurrentUICulture 屬性，對象是所有
              使用這個強類型資源類別的資源查閱。
            </summary>
        </member>
        <member name="P:TEC.Core.Scheduler.Timers.Resource.TimersTimerStorage.TimerStatusNotSupportedOnStartException">
            <summary>
              查詢類似 You cannot start timer when TimerStatus is not &quot;{0}&quot;. 的當地語系化字串。
            </summary>
        </member>
        <member name="T:TEC.Core.Scheduler.Timers.ThreadingTimerStorage">
            <summary>
            封裝<see cref="T:System.Threading.Timer"/>的排程器類別，此類別不能被繼承
            </summary>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.ThreadingTimerStorage.#ctor(TEC.Core.Scheduler.Timers.ITimerEvent,Itenso.TimePeriod.ITimePeriodCollection,System.Int32,TEC.Core.Scheduler.Timers.NextTimeEvaluationType)">
            <summary>
            初始化<see cref="T:System.Threading.Timer"/>資訊的物件，並指定這個工作的有效時間區間
            </summary>
            <param name="timerEvent">當每次時間重置時要執行的事件</param>
            <param name="timePeriodCollection">對於這個<see cref="T:System.Timers.Timer"/>而言，有效的執行區間</param>
            <param name="interval">每次時間逾期重置的間隔(以毫秒為單位 1000毫秒=1秒)</param>
            <param name="nextTimeEvaluationType">下次執行時間的基礎，當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.ExecutionEndTime"/>時，以每次執行完成後，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>為下次執行時間。
            當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.StartUpTime"/>時，以第一次執行時間為主，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>的倍數至未來最接近現在的時間為下次執行時間。主要差別在於後者時間不會偏移主要執行時間。</param>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.ThreadingTimerStorage.#ctor(TEC.Core.Scheduler.Timers.ITimerEvent,Itenso.TimePeriod.ITimePeriodCollection,System.TimeSpan,TEC.Core.Scheduler.Timers.NextTimeEvaluationType)">
            <summary>
            初始化<see cref="T:System.Threading.Timer"/>資訊的物件，並指定這個工作的有效時間區間
            </summary>
            <param name="timerEvent">當每次時間重置時要執行的事件</param>
            <param name="timePeriodCollection">對於這個<see cref="T:System.Timers.Timer"/>而言，有效的執行區間</param>
            <param name="timeSpan">每次時間逾期重置的間隔</param>
            <param name="nextTimeEvaluationType">下次執行時間的基礎，當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.ExecutionEndTime"/>時，以每次執行完成後，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>為下次執行時間。
            當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.StartUpTime"/>時，以第一次執行時間為主，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>的倍數至未來最接近現在的時間為下次執行時間。主要差別在於後者時間不會偏移主要執行時間。</param>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.ThreadingTimerStorage.start">
            <summary>
            開始計時器。
            </summary>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.ThreadingTimerStorage.evaluateStarting">
            <summary>
            評估是否開始計時器，若可以開始則立即開始，若沒有下次執行的時間則停止執行。
            </summary>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.ThreadingTimerStorage.Dispose(System.Boolean)">
            <summary>
            釋放目前物件的資源
            </summary>
            <param name="isDisposing">是否開始處理物件的資源釋放行為</param>
        </member>
        <member name="P:TEC.Core.Scheduler.Timers.ThreadingTimerStorage.Timer">
            <summary>
            取得與此物件關聯的<see cref="T:System.Threading.Timer"/>
            </summary>
        </member>
        <member name="E:TEC.Core.Scheduler.Timers.ThreadingTimerStorage.OnUnhandledExceptionThrew">
            <summary>
            當在執行排程事件時，有未處理的例外狀況發生時引發
            </summary>
        </member>
        <member name="T:TEC.Core.Scheduler.Timers.TimerManager">
            <summary>
            時間排程器的管理類別，此類別不能被繼承。
            </summary>
            <remarks>
            為了應用程式的穩定性，請盡量考慮初始化較少的<see cref="T:TEC.Core.Scheduler.Timers.TimerManager"/>物件。
            </remarks>
        </member>
        <member name="F:TEC.Core.Scheduler.Timers.TimerManager.managedTimerObservableCollectionLazy">
            <summary>
            受管理的Timer管理集合
            </summary>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimerManager.#ctor">
            <summary>
            初始化管理Timer的物件
            </summary>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimerManager.Finalize">
            <summary>
            解構此物件
            </summary>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimerManager.createTimersTimer(TEC.Core.Scheduler.Timers.ITimerEvent,Itenso.TimePeriod.ITimePeriodCollection,System.ComponentModel.ISynchronizeInvoke,System.Int32,TEC.Core.Scheduler.Timers.NextTimeEvaluationType)">
            <summary>
            建立<see cref="T:TEC.Core.Scheduler.Timers.TimersTimerStorage"/>並將其加入目前<see cref="T:TEC.Core.Scheduler.Timers.TimerManager"/>執行個體的受管理清單
            </summary>
            <param name="timerEvent">當每次interval耗盡時要執行的事件</param>
            <param name="timePeriodCollection">指定有效執行區間集合</param>
            <param name="interval">在有效時間內執行的間隔毫秒數</param>
            <param name="synchronizingObject">用來封送處理事件處理常式的呼叫 (當間隔已經耗盡時所發出)，若不需要則為<c>null</c></param>
            <param name="nextTimeEvaluationType">下次執行時間的基礎，當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.ExecutionEndTime"/>時，以每次執行完成後，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>為下次執行時間。
            當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.StartUpTime"/>時，以第一次執行時間為主，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>的倍數至未來最接近現在的時間為下次執行時間。主要差別在於後者時間不會偏移主要執行時間。</param>
            <returns>傳回已受管理的<see cref="T:TEC.Core.Scheduler.Timers.TimersTimerStorage"/></returns>
            <seealso cref="T:TEC.Core.Scheduler.Timers.TimersTimerStorage"/>
            <remarks>
            若要將其物件從管理清單中移除並立即停止排程，僅需呼叫該物件的Dispose()方法即可。
            </remarks>
            <exception cref="T:System.ArgumentNullException">當<paramref name="timerEvent"/>為<c>null</c>時擲出。</exception>
            <example>
            <para>TimersTimerEvent.cs</para>
            <code lang="C#">
            <summary>
            要排程執行程式的類別
            </summary>
            public class TimersTimerEvent : ITimerEvent
            {
                private static readonly object syncObj = new object();
                /// &lt;summary&gt;
                /// 初始化排程事件
                /// &lt;/summary&gt;
                /// &lt;param name="timerEventName"&gt;事件名稱&lt;/param&gt;
                public TimersTimerEvent(string timerEventName)
                {
                    this.TimerEventName = timerEventName;
                }
                /// &lt;summary&gt;
                /// 物件是否已經完成清理
                /// &lt;/summary&gt;
                private bool isDisposed = false;
                public void execute()
                {
                    try
                    {
                        //每次指定的間隔(此例為5000毫秒)後要執行的內容
                        Console.WriteLine(String.Format("排程\"{0}\"已在{1:yyyy/MM/dd HH:mm:ss}執行。", this.TimerEventName, DateTime.Now));
                        //執行您所規劃的程式碼
                    }
                    catch (Exception ex)
                    {
                        //需要考慮到例外狀況以防止排程執行個體中斷
                        Console.WriteLine(String.Format("排程\"{0}\"已在{1:yyyy/MM/dd HH:mm:ss}發生錯誤{2}。", this.TimerEventName, DateTime.Now, ex.Message));
                    }
                }
                /// &lt;summary&gt;
                /// 釋放目前物件的資源
                /// &lt;/summary&gt;
                /// &lt;param name="isDisposing"&gt;是否開始處理物件的資源釋放行為&lt;/param&gt;
                protected virtual void Dispose(bool isDisposing)
                {
                    if (!isDisposed)
                    {
                        lock (syncObj)
                        {
                            if (isDisposing)
                            {
                                //釋放Managed Resource
                            }
                            //釋放Unmanaged Resource
                            this.isDisposed = true;
                        }
                    }
                }
                /// &lt;summary&gt;
                /// 釋放目前物件的資源
                /// &lt;/summary&gt;
                public void Dispose()
                {
                    this.Dispose(true);
                    GC.SuppressFinalize(this);
                }
                /// &lt;summary&gt;
                /// 取得事件名稱
                /// &lt;/summary&gt;
                public string TimerEventName { private set; get; }
            }
            </code>
            <para>TimerManagerDemo.cs</para>
            <code>
            public class TimerManagerDemo
            {
                public static void main()
                {
                    //using TEC.Core.Scheduler.Timers;
                    //
                    TimerManager timerManager = new TimerManager();
                    timerManager.PropertyChanged += Instance_PropertyChanged;
                    //
                    //using Itenso.TimePeriod;  
                    // 詳細資料請參考 http://www.codeproject.com/Articles/168662/Time-Period-Library-for-NET
                    //建立從現在時間往後算五秒至無限大的時間區間
                    //TimePeriodCollection collection1 = new TimePeriodCollection(new[] { new TimeRange(DateTime.Now.AddSeconds(5), DateTime.MaxValue) });
                    //只連續執行一分鐘
                    TimePeriodCollection collection1 = new TimePeriodCollection(new[] { new TimeRange(DateTime.Now.AddSeconds(5), DateTime.Now.AddSeconds(20)) });
                    #region TimersTimer
                    //
                    //建立時間排程執行個體
                    TimersTimerEvent timersTimerEvent = new TimersTimerEvent("Event1");
                    TimersTimerStorage storage1 = timerManager.createTimersTimer(timersTimerEvent,
                    collection1,
                    null,
                        //每5000毫秒執行一次
                    5000,//或 new TimeSpan(0,0,0,0,5000)
                        //以起始時間為主的累加5秒為執行時間
                    NextTimeEvaluationType.StartUpTime);
                    //當時間排程屬性發生變更時引發的事件
                    storage1.PropertyChanged += timerStorageBase_PropertyChanged;
                    //當執行事件時有未處理的例外狀況時發生
                    storage1.OnUnhandledExceptionThrew += timerStorageBase_OnUnhandledExceptionThrew;
                    //
                    //開始執行排程
                    storage1.start();
                    #endregion
                    #region ThreadingTimer
                    TimersTimerEvent timersTimerEvent2 = new TimersTimerEvent("Event2");
                    ThreadingTimerStorage storage2 = timerManager.createThreadingTimer(timersTimerEvent2,
                    collection1,
                        //每5000毫秒執行一次
                    5000,//或 new TimeSpan(0,0,0,0,5000)
                        //以起始時間為主的累加5秒為執行時間
                    NextTimeEvaluationType.StartUpTime);
                    //當時間排程屬性發生變更時引發的事件
                    storage2.PropertyChanged += timerStorageBase_PropertyChanged;
                    //當執行事件時有未處理的例外狀況時發生
                    storage2.OnUnhandledExceptionThrew += timerStorageBase_OnUnhandledExceptionThrew;
                    //
                    //開始執行排程
                    storage2.start();
                    #endregion
                    //
                    //取得所有相依於TimersTimerEvent物件的排程器
                    List&lt;TimerStorageBase&gt; dependOnInstanceTimerStorageList = timerManager.getManagedTimerStorage(timersTimerEvent);
                    //取得所有相依於TimersTimerEvent類型的排程器
                    List&lt;TimerStorageBase&gt; dependOnTypeTimerStorageList = timerManager.getManagedTimerStorage(typeof(TimersTimerEvent));
                    
                    //立即停止指定排程器，並從受管理的清單中移除
                    storage2.Dispose();//立即停止storag2參考的排程器，並從timerManager中移除其參考
                }
                static void Instance_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
                {
                    TimerManager timerManager = sender as TimerManager;
                    if (e.PropertyName == "ManagedTimerReadOnlyObservableCollection")
                    {
                        //當受管理的所有排程集合發生變更時
                        Console.WriteLine(String.Format("受管理的排程數量變更為{0}", timerManager.ManagedTimerReadOnlyObservableCollection.Count));
                    }
                }
                static void timerStorageBase_OnUnhandledExceptionThrew(object sender, UnhandledExceptionEventArgs e)
                {
                    Console.WriteLine(String.Format("排程器執行時發生錯誤:{0}。正在準備下次執行(當最後一次執行時則為停止)。", (e.ExceptionObject as Exception).Message));
                }
                /// &lt;summary&gt;
                /// 當時間排程屬性發生變更時引發的事件
                /// &lt;/summary&gt;
                /// &lt;param name="sender"&gt;發生變更的排程物件&lt;/param&gt;
                /// &lt;param name="e"&gt;相關變更的屬性&lt;/param&gt;
                static void timerStorageBase_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
                {
                    TimerStorageBase timerStorageBase = sender as TimerStorageBase;
                    if (e.PropertyName == "TimerStatus")
                    {
                        //發生變更的屬性為TimersTimerStorage.TimerStatus
                        Console.WriteLine(String.Format("{0} 的 TimerStatus 已變更為 {1}", timerStorageBase.GetType().FullName, timerStorageBase.TimerStatus));
                    }
                    if (e.PropertyName == "NextExecuteDateTime")
                    {
                        //發生變更的屬性為TimersTimerStorage.NextExecuteDateTime
                        Console.WriteLine(String.Format("{0} 的 下一次執行時間已變更為 {1}", timerStorageBase.GetType().FullName,
                            timerStorageBase.NextExecuteDateTime.HasValue ? timerStorageBase.NextExecuteDateTime.Value.ToString("yyyy/MM/dd HH:mm:ss") : "不再執行"));
                    }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimerManager.createTimersTimer(TEC.Core.Scheduler.Timers.ITimerEvent,Itenso.TimePeriod.ITimePeriodCollection,System.ComponentModel.ISynchronizeInvoke,System.TimeSpan,TEC.Core.Scheduler.Timers.NextTimeEvaluationType)">
            <summary>
            建立<see cref="T:TEC.Core.Scheduler.Timers.TimersTimerStorage"/>並將其加入目前<see cref="T:TEC.Core.Scheduler.Timers.TimerManager"/>執行個體的受管理清單
            </summary>
            <param name="timerEvent">當每次interval耗盡時要執行的事件</param>
            <param name="timePeriodCollection">指定有效執行區間集合</param>
            <param name="timeSpan">在有效時間內執行的間隔</param>
            <param name="synchronizingObject">用來封送處理事件處理常式的呼叫 (當間隔已經耗盡時所發出)，若不需要則為<c>null</c></param>
            <param name="nextTimeEvaluationType">下次執行時間的基礎，當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.ExecutionEndTime"/>時，以每次執行完成後，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>為下次執行時間。
            當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.StartUpTime"/>時，以第一次執行時間為主，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>的倍數至未來最接近現在的時間為下次執行時間。主要差別在於後者時間不會偏移主要執行時間。</param>
            <returns>傳回已受管理的<see cref="T:TEC.Core.Scheduler.Timers.TimersTimerStorage"/></returns>
            <seealso cref="T:TEC.Core.Scheduler.Timers.TimersTimerStorage"/>
            <remarks>
            若要將其物件從管理清單中移除並立即停止排程，僅需呼叫該物件的Dispose()方法即可。
            </remarks>
            <exception cref="T:System.ArgumentNullException">當<paramref name="timerEvent"/>為<c>null</c>時擲出。</exception>
            <example>
            <para>TimersTimerEvent.cs</para>
            <code lang="C#">
            <summary>
            要排程執行程式的類別
            </summary>
            public class TimersTimerEvent : ITimerEvent
            {
                private static readonly object syncObj = new object();
                /// &lt;summary&gt;
                /// 初始化排程事件
                /// &lt;/summary&gt;
                /// &lt;param name="timerEventName"&gt;事件名稱&lt;/param&gt;
                public TimersTimerEvent(string timerEventName)
                {
                    this.TimerEventName = timerEventName;
                }
                /// &lt;summary&gt;
                /// 物件是否已經完成清理
                /// &lt;/summary&gt;
                private bool isDisposed = false;
                public void execute()
                {
                    try
                    {
                        //每次指定的間隔(此例為5000毫秒)後要執行的內容
                        Console.WriteLine(String.Format("排程\"{0}\"已在{1:yyyy/MM/dd HH:mm:ss}執行。", this.TimerEventName, DateTime.Now));
                        //執行您所規劃的程式碼
                    }
                    catch (Exception ex)
                    {
                        //需要考慮到例外狀況以防止排程執行個體中斷
                        Console.WriteLine(String.Format("排程\"{0}\"已在{1:yyyy/MM/dd HH:mm:ss}發生錯誤{2}。", this.TimerEventName, DateTime.Now, ex.Message));
                    }
                }
                /// &lt;summary&gt;
                /// 釋放目前物件的資源
                /// &lt;/summary&gt;
                /// &lt;param name="isDisposing"&gt;是否開始處理物件的資源釋放行為&lt;/param&gt;
                protected virtual void Dispose(bool isDisposing)
                {
                    if (!isDisposed)
                    {
                        lock (syncObj)
                        {
                            if (isDisposing)
                            {
                                //釋放Managed Resource
                            }
                            //釋放Unmanaged Resource
                            this.isDisposed = true;
                        }
                    }
                }
                /// &lt;summary&gt;
                /// 釋放目前物件的資源
                /// &lt;/summary&gt;
                public void Dispose()
                {
                    this.Dispose(true);
                    GC.SuppressFinalize(this);
                }
                /// &lt;summary&gt;
                /// 取得事件名稱
                /// &lt;/summary&gt;
                public string TimerEventName { private set; get; }
            }
            </code>
            <para>TimerManagerDemo.cs</para>
            <code>
            public class TimerManagerDemo
            {
                public static void main()
                {
                    //using TEC.Core.Scheduler.Timers;
                    //
                    TimerManager timerManager = new TimerManager();
                    timerManager.PropertyChanged += Instance_PropertyChanged;
                    //
                    //using Itenso.TimePeriod;  
                    // 詳細資料請參考 http://www.codeproject.com/Articles/168662/Time-Period-Library-for-NET
                    //建立從現在時間往後算五秒至無限大的時間區間
                    //TimePeriodCollection collection1 = new TimePeriodCollection(new[] { new TimeRange(DateTime.Now.AddSeconds(5), DateTime.MaxValue) });
                    //只連續執行一分鐘
                    TimePeriodCollection collection1 = new TimePeriodCollection(new[] { new TimeRange(DateTime.Now.AddSeconds(5), DateTime.Now.AddSeconds(20)) });
                    #region TimersTimer
                    //
                    //建立時間排程執行個體
                    TimersTimerEvent timersTimerEvent = new TimersTimerEvent("Event1");
                    TimersTimerStorage storage1 = timerManager.createTimersTimer(timersTimerEvent,
                    collection1,
                    null,
                        //每5000毫秒執行一次
                    5000,//或 new TimeSpan(0,0,0,0,5000)
                        //以起始時間為主的累加5秒為執行時間
                    NextTimeEvaluationType.StartUpTime);
                    //當時間排程屬性發生變更時引發的事件
                    storage1.PropertyChanged += timerStorageBase_PropertyChanged;
                    //當執行事件時有未處理的例外狀況時發生
                    storage1.OnUnhandledExceptionThrew += timerStorageBase_OnUnhandledExceptionThrew;
                    //
                    //開始執行排程
                    storage1.start();
                    #endregion
                    #region ThreadingTimer
                    TimersTimerEvent timersTimerEvent2 = new TimersTimerEvent("Event2");
                    ThreadingTimerStorage storage2 = timerManager.createThreadingTimer(timersTimerEvent2,
                    collection1,
                        //每5000毫秒執行一次
                    5000,//或 new TimeSpan(0,0,0,0,5000)
                        //以起始時間為主的累加5秒為執行時間
                    NextTimeEvaluationType.StartUpTime);
                    //當時間排程屬性發生變更時引發的事件
                    storage2.PropertyChanged += timerStorageBase_PropertyChanged;
                    //當執行事件時有未處理的例外狀況時發生
                    storage2.OnUnhandledExceptionThrew += timerStorageBase_OnUnhandledExceptionThrew;
                    //
                    //開始執行排程
                    storage2.start();
                    #endregion
                    //
                    //取得所有相依於TimersTimerEvent物件的排程器
                    List&lt;TimerStorageBase&gt; dependOnInstanceTimerStorageList = timerManager.getManagedTimerStorage(timersTimerEvent);
                    //取得所有相依於TimersTimerEvent類型的排程器
                    List&lt;TimerStorageBase&gt; dependOnTypeTimerStorageList = timerManager.getManagedTimerStorage(typeof(TimersTimerEvent));
                    
                    //立即停止指定排程器，並從受管理的清單中移除
                    storage2.Dispose();//立即停止storag2參考的排程器，並從timerManager中移除其參考
                }
                static void Instance_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
                {
                    TimerManager timerManager = sender as TimerManager;
                    if (e.PropertyName == "ManagedTimerReadOnlyObservableCollection")
                    {
                        //當受管理的所有排程集合發生變更時
                        Console.WriteLine(String.Format("受管理的排程數量變更為{0}", timerManager.ManagedTimerReadOnlyObservableCollection.Count));
                    }
                }
                static void timerStorageBase_OnUnhandledExceptionThrew(object sender, UnhandledExceptionEventArgs e)
                {
                    Console.WriteLine(String.Format("排程器執行時發生錯誤:{0}。正在準備下次執行(當最後一次執行時則為停止)。", (e.ExceptionObject as Exception).Message));
                }
                /// &lt;summary&gt;
                /// 當時間排程屬性發生變更時引發的事件
                /// &lt;/summary&gt;
                /// &lt;param name="sender"&gt;發生變更的排程物件&lt;/param&gt;
                /// &lt;param name="e"&gt;相關變更的屬性&lt;/param&gt;
                static void timerStorageBase_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
                {
                    TimerStorageBase timerStorageBase = sender as TimerStorageBase;
                    if (e.PropertyName == "TimerStatus")
                    {
                        //發生變更的屬性為TimersTimerStorage.TimerStatus
                        Console.WriteLine(String.Format("{0} 的 TimerStatus 已變更為 {1}", timerStorageBase.GetType().FullName, timerStorageBase.TimerStatus));
                    }
                    if (e.PropertyName == "NextExecuteDateTime")
                    {
                        //發生變更的屬性為TimersTimerStorage.NextExecuteDateTime
                        Console.WriteLine(String.Format("{0} 的 下一次執行時間已變更為 {1}", timerStorageBase.GetType().FullName,
                            timerStorageBase.NextExecuteDateTime.HasValue ? timerStorageBase.NextExecuteDateTime.Value.ToString("yyyy/MM/dd HH:mm:ss") : "不再執行"));
                    }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimerManager.createThreadingTimer(TEC.Core.Scheduler.Timers.ITimerEvent,Itenso.TimePeriod.ITimePeriodCollection,System.Int32,TEC.Core.Scheduler.Timers.NextTimeEvaluationType)">
            <summary>
            建立<see cref="T:TEC.Core.Scheduler.Timers.ThreadingTimerStorage"/>並將其加入目前<see cref="T:TEC.Core.Scheduler.Timers.TimerManager"/>執行個體的受管理清單
            </summary>
            <param name="timerEvent">當每次interval耗盡時要執行的事件</param>
            <param name="timePeriodCollection">指定有效執行區間集合</param>
            <param name="interval">在有效時間內執行的間隔毫秒數</param>
            <param name="nextTimeEvaluationType">下次執行時間的基礎，當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.ExecutionEndTime"/>時，以每次執行完成後，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>為下次執行時間。
            當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.StartUpTime"/>時，以第一次執行時間為主，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>的倍數至未來最接近現在的時間為下次執行時間。主要差別在於後者時間不會偏移主要執行時間。</param>
            <returns>傳回已受管理的<see cref="T:TEC.Core.Scheduler.Timers.ThreadingTimerStorage"/></returns>
            <seealso cref="T:TEC.Core.Scheduler.Timers.ThreadingTimerStorage"/>
            <remarks>
            若要將其物件從管理清單中移除並立即停止排程，僅需呼叫該物件的Dispose()方法即可。
            </remarks>
            <exception cref="T:System.ArgumentNullException">當<paramref name="timerEvent"/>為<c>null</c>時擲出。</exception>
            <example>
            <para>TimersTimerEvent.cs</para>
            <code lang="C#">
            <summary>
            要排程執行程式的類別
            </summary>
            public class TimersTimerEvent : ITimerEvent
            {
                private static readonly object syncObj = new object();
                /// &lt;summary&gt;
                /// 初始化排程事件
                /// &lt;/summary&gt;
                /// &lt;param name="timerEventName"&gt;事件名稱&lt;/param&gt;
                public TimersTimerEvent(string timerEventName)
                {
                    this.TimerEventName = timerEventName;
                }
                /// &lt;summary&gt;
                /// 物件是否已經完成清理
                /// &lt;/summary&gt;
                private bool isDisposed = false;
                public void execute()
                {
                    try
                    {
                        //每次指定的間隔(此例為5000毫秒)後要執行的內容
                        Console.WriteLine(String.Format("排程\"{0}\"已在{1:yyyy/MM/dd HH:mm:ss}執行。", this.TimerEventName, DateTime.Now));
                        //執行您所規劃的程式碼
                    }
                    catch (Exception ex)
                    {
                        //需要考慮到例外狀況以防止排程執行個體中斷
                        Console.WriteLine(String.Format("排程\"{0}\"已在{1:yyyy/MM/dd HH:mm:ss}發生錯誤{2}。", this.TimerEventName, DateTime.Now, ex.Message));
                    }
                }
                /// &lt;summary&gt;
                /// 釋放目前物件的資源
                /// &lt;/summary&gt;
                /// &lt;param name="isDisposing"&gt;是否開始處理物件的資源釋放行為&lt;/param&gt;
                protected virtual void Dispose(bool isDisposing)
                {
                    if (!isDisposed)
                    {
                        lock (syncObj)
                        {
                            if (isDisposing)
                            {
                                //釋放Managed Resource
                            }
                            //釋放Unmanaged Resource
                            this.isDisposed = true;
                        }
                    }
                }
                /// &lt;summary&gt;
                /// 釋放目前物件的資源
                /// &lt;/summary&gt;
                public void Dispose()
                {
                    this.Dispose(true);
                    GC.SuppressFinalize(this);
                }
                /// &lt;summary&gt;
                /// 取得事件名稱
                /// &lt;/summary&gt;
                public string TimerEventName { private set; get; }
            }
            </code>
            <para>TimerManagerDemo.cs</para>
            <code>
            public class TimerManagerDemo
            {
                public static void main()
                {
                    //using TEC.Core.Scheduler.Timers;
                    //
                    TimerManager timerManager = new TimerManager();
                    timerManager.PropertyChanged += Instance_PropertyChanged;
                    //
                    //using Itenso.TimePeriod;  
                    // 詳細資料請參考 http://www.codeproject.com/Articles/168662/Time-Period-Library-for-NET
                    //建立從現在時間往後算五秒至無限大的時間區間
                    //TimePeriodCollection collection1 = new TimePeriodCollection(new[] { new TimeRange(DateTime.Now.AddSeconds(5), DateTime.MaxValue) });
                    //只連續執行一分鐘
                    TimePeriodCollection collection1 = new TimePeriodCollection(new[] { new TimeRange(DateTime.Now.AddSeconds(5), DateTime.Now.AddSeconds(20)) });
                    #region TimersTimer
                    //
                    //建立時間排程執行個體
                    TimersTimerEvent timersTimerEvent = new TimersTimerEvent("Event1");
                    TimersTimerStorage storage1 = timerManager.createTimersTimer(timersTimerEvent,
                    collection1,
                    null,
                        //每5000毫秒執行一次
                    5000,//或 new TimeSpan(0,0,0,0,5000)
                        //以起始時間為主的累加5秒為執行時間
                    NextTimeEvaluationType.StartUpTime);
                    //當時間排程屬性發生變更時引發的事件
                    storage1.PropertyChanged += timerStorageBase_PropertyChanged;
                    //當執行事件時有未處理的例外狀況時發生
                    storage1.OnUnhandledExceptionThrew += timerStorageBase_OnUnhandledExceptionThrew;
                    //
                    //開始執行排程
                    storage1.start();
                    #endregion
                    #region ThreadingTimer
                    TimersTimerEvent timersTimerEvent2 = new TimersTimerEvent("Event2");
                    ThreadingTimerStorage storage2 = timerManager.createThreadingTimer(timersTimerEvent2,
                    collection1,
                        //每5000毫秒執行一次
                    5000,//或 new TimeSpan(0,0,0,0,5000)
                        //以起始時間為主的累加5秒為執行時間
                    NextTimeEvaluationType.StartUpTime);
                    //當時間排程屬性發生變更時引發的事件
                    storage2.PropertyChanged += timerStorageBase_PropertyChanged;
                    //當執行事件時有未處理的例外狀況時發生
                    storage2.OnUnhandledExceptionThrew += timerStorageBase_OnUnhandledExceptionThrew;
                    //
                    //開始執行排程
                    storage2.start();
                    #endregion
                    //
                    //取得所有相依於TimersTimerEvent物件的排程器
                    List&lt;TimerStorageBase&gt; dependOnInstanceTimerStorageList = timerManager.getManagedTimerStorage(timersTimerEvent);
                    //取得所有相依於TimersTimerEvent類型的排程器
                    List&lt;TimerStorageBase&gt; dependOnTypeTimerStorageList = timerManager.getManagedTimerStorage(typeof(TimersTimerEvent));
                    
                    //立即停止指定排程器，並從受管理的清單中移除
                    storage2.Dispose();//立即停止storag2參考的排程器，並從timerManager中移除其參考
                }
                static void Instance_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
                {
                    TimerManager timerManager = sender as TimerManager;
                    if (e.PropertyName == "ManagedTimerReadOnlyObservableCollection")
                    {
                        //當受管理的所有排程集合發生變更時
                        Console.WriteLine(String.Format("受管理的排程數量變更為{0}", timerManager.ManagedTimerReadOnlyObservableCollection.Count));
                    }
                }
                static void timerStorageBase_OnUnhandledExceptionThrew(object sender, UnhandledExceptionEventArgs e)
                {
                    Console.WriteLine(String.Format("排程器執行時發生錯誤:{0}。正在準備下次執行(當最後一次執行時則為停止)。", (e.ExceptionObject as Exception).Message));
                }
                /// &lt;summary&gt;
                /// 當時間排程屬性發生變更時引發的事件
                /// &lt;/summary&gt;
                /// &lt;param name="sender"&gt;發生變更的排程物件&lt;/param&gt;
                /// &lt;param name="e"&gt;相關變更的屬性&lt;/param&gt;
                static void timerStorageBase_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
                {
                    TimerStorageBase timerStorageBase = sender as TimerStorageBase;
                    if (e.PropertyName == "TimerStatus")
                    {
                        //發生變更的屬性為TimersTimerStorage.TimerStatus
                        Console.WriteLine(String.Format("{0} 的 TimerStatus 已變更為 {1}", timerStorageBase.GetType().FullName, timerStorageBase.TimerStatus));
                    }
                    if (e.PropertyName == "NextExecuteDateTime")
                    {
                        //發生變更的屬性為TimersTimerStorage.NextExecuteDateTime
                        Console.WriteLine(String.Format("{0} 的 下一次執行時間已變更為 {1}", timerStorageBase.GetType().FullName,
                            timerStorageBase.NextExecuteDateTime.HasValue ? timerStorageBase.NextExecuteDateTime.Value.ToString("yyyy/MM/dd HH:mm:ss") : "不再執行"));
                    }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimerManager.createThreadingTimer(TEC.Core.Scheduler.Timers.ITimerEvent,Itenso.TimePeriod.ITimePeriodCollection,System.TimeSpan,TEC.Core.Scheduler.Timers.NextTimeEvaluationType)">
            <summary>
            建立<see cref="T:TEC.Core.Scheduler.Timers.ThreadingTimerStorage"/>並將其加入目前<see cref="T:TEC.Core.Scheduler.Timers.TimerManager"/>執行個體的受管理清單
            </summary>
            <param name="timerEvent">當每次interval耗盡時要執行的事件</param>
            <param name="timePeriodCollection">指定有效執行區間集合</param>
            <param name="timeSpan">在有效時間內執行的間隔</param>
            <param name="nextTimeEvaluationType">下次執行時間的基礎，當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.ExecutionEndTime"/>時，以每次執行完成後，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>為下次執行時間。
            當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.StartUpTime"/>時，以第一次執行時間為主，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>的倍數至未來最接近現在的時間為下次執行時間。主要差別在於後者時間不會偏移主要執行時間。</param>
            <returns>傳回已受管理的<see cref="T:TEC.Core.Scheduler.Timers.ThreadingTimerStorage"/></returns>
            <seealso cref="T:TEC.Core.Scheduler.Timers.ThreadingTimerStorage"/>
            <remarks>
            若要將其物件從管理清單中移除並立即停止排程，僅需呼叫該物件的Dispose()方法即可。
            </remarks>
            <exception cref="T:System.ArgumentNullException">當<paramref name="timerEvent"/>為<c>null</c>時擲出。</exception>
            <example>
            <para>TimersTimerEvent.cs</para>
            <code lang="C#">
            <summary>
            要排程執行程式的類別
            </summary>
            public class TimersTimerEvent : ITimerEvent
            {
                private static readonly object syncObj = new object();
                /// &lt;summary&gt;
                /// 初始化排程事件
                /// &lt;/summary&gt;
                /// &lt;param name="timerEventName"&gt;事件名稱&lt;/param&gt;
                public TimersTimerEvent(string timerEventName)
                {
                    this.TimerEventName = timerEventName;
                }
                /// &lt;summary&gt;
                /// 物件是否已經完成清理
                /// &lt;/summary&gt;
                private bool isDisposed = false;
                public void execute()
                {
                    try
                    {
                        //每次指定的間隔(此例為5000毫秒)後要執行的內容
                        Console.WriteLine(String.Format("排程\"{0}\"已在{1:yyyy/MM/dd HH:mm:ss}執行。", this.TimerEventName, DateTime.Now));
                        //執行您所規劃的程式碼
                    }
                    catch (Exception ex)
                    {
                        //需要考慮到例外狀況以防止排程執行個體中斷
                        Console.WriteLine(String.Format("排程\"{0}\"已在{1:yyyy/MM/dd HH:mm:ss}發生錯誤{2}。", this.TimerEventName, DateTime.Now, ex.Message));
                    }
                }
                /// &lt;summary&gt;
                /// 釋放目前物件的資源
                /// &lt;/summary&gt;
                /// &lt;param name="isDisposing"&gt;是否開始處理物件的資源釋放行為&lt;/param&gt;
                protected virtual void Dispose(bool isDisposing)
                {
                    if (!isDisposed)
                    {
                        lock (syncObj)
                        {
                            if (isDisposing)
                            {
                                //釋放Managed Resource
                            }
                            //釋放Unmanaged Resource
                            this.isDisposed = true;
                        }
                    }
                }
                /// &lt;summary&gt;
                /// 釋放目前物件的資源
                /// &lt;/summary&gt;
                public void Dispose()
                {
                    this.Dispose(true);
                    GC.SuppressFinalize(this);
                }
                /// &lt;summary&gt;
                /// 取得事件名稱
                /// &lt;/summary&gt;
                public string TimerEventName { private set; get; }
            }
            </code>
            <para>TimerManagerDemo.cs</para>
            <code>
            public class TimerManagerDemo
            {
                public static void main()
                {
                    //using TEC.Core.Scheduler.Timers;
                    //
                    TimerManager timerManager = new TimerManager();
                    timerManager.PropertyChanged += Instance_PropertyChanged;
                    //
                    //using Itenso.TimePeriod;  
                    // 詳細資料請參考 http://www.codeproject.com/Articles/168662/Time-Period-Library-for-NET
                    //建立從現在時間往後算五秒至無限大的時間區間
                    //TimePeriodCollection collection1 = new TimePeriodCollection(new[] { new TimeRange(DateTime.Now.AddSeconds(5), DateTime.MaxValue) });
                    //只連續執行一分鐘
                    TimePeriodCollection collection1 = new TimePeriodCollection(new[] { new TimeRange(DateTime.Now.AddSeconds(5), DateTime.Now.AddSeconds(20)) });
                    #region TimersTimer
                    //
                    //建立時間排程執行個體
                    TimersTimerEvent timersTimerEvent = new TimersTimerEvent("Event1");
                    TimersTimerStorage storage1 = timerManager.createTimersTimer(timersTimerEvent,
                    collection1,
                    null,
                        //每5000毫秒執行一次
                    5000,//或 new TimeSpan(0,0,0,0,5000)
                        //以起始時間為主的累加5秒為執行時間
                    NextTimeEvaluationType.StartUpTime);
                    //當時間排程屬性發生變更時引發的事件
                    storage1.PropertyChanged += timerStorageBase_PropertyChanged;
                    //當執行事件時有未處理的例外狀況時發生
                    storage1.OnUnhandledExceptionThrew += timerStorageBase_OnUnhandledExceptionThrew;
                    //
                    //開始執行排程
                    storage1.start();
                    #endregion
                    #region ThreadingTimer
                    TimersTimerEvent timersTimerEvent2 = new TimersTimerEvent("Event2");
                    ThreadingTimerStorage storage2 = timerManager.createThreadingTimer(timersTimerEvent2,
                    collection1,
                        //每5000毫秒執行一次
                    5000,//或 new TimeSpan(0,0,0,0,5000)
                        //以起始時間為主的累加5秒為執行時間
                    NextTimeEvaluationType.StartUpTime);
                    //當時間排程屬性發生變更時引發的事件
                    storage2.PropertyChanged += timerStorageBase_PropertyChanged;
                    //當執行事件時有未處理的例外狀況時發生
                    storage2.OnUnhandledExceptionThrew += timerStorageBase_OnUnhandledExceptionThrew;
                    //
                    //開始執行排程
                    storage2.start();
                    #endregion
                    //
                    //取得所有相依於TimersTimerEvent物件的排程器
                    List&lt;TimerStorageBase&gt; dependOnInstanceTimerStorageList = timerManager.getManagedTimerStorage(timersTimerEvent);
                    //取得所有相依於TimersTimerEvent類型的排程器
                    List&lt;TimerStorageBase&gt; dependOnTypeTimerStorageList = timerManager.getManagedTimerStorage(typeof(TimersTimerEvent));
                    
                    //立即停止指定排程器，並從受管理的清單中移除
                    storage2.Dispose();//立即停止storag2參考的排程器，並從timerManager中移除其參考
                }
                static void Instance_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
                {
                    TimerManager timerManager = sender as TimerManager;
                    if (e.PropertyName == "ManagedTimerReadOnlyObservableCollection")
                    {
                        //當受管理的所有排程集合發生變更時
                        Console.WriteLine(String.Format("受管理的排程數量變更為{0}", timerManager.ManagedTimerReadOnlyObservableCollection.Count));
                    }
                }
                static void timerStorageBase_OnUnhandledExceptionThrew(object sender, UnhandledExceptionEventArgs e)
                {
                    Console.WriteLine(String.Format("排程器執行時發生錯誤:{0}。正在準備下次執行(當最後一次執行時則為停止)。", (e.ExceptionObject as Exception).Message));
                }
                /// &lt;summary&gt;
                /// 當時間排程屬性發生變更時引發的事件
                /// &lt;/summary&gt;
                /// &lt;param name="sender"&gt;發生變更的排程物件&lt;/param&gt;
                /// &lt;param name="e"&gt;相關變更的屬性&lt;/param&gt;
                static void timerStorageBase_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
                {
                    TimerStorageBase timerStorageBase = sender as TimerStorageBase;
                    if (e.PropertyName == "TimerStatus")
                    {
                        //發生變更的屬性為TimersTimerStorage.TimerStatus
                        Console.WriteLine(String.Format("{0} 的 TimerStatus 已變更為 {1}", timerStorageBase.GetType().FullName, timerStorageBase.TimerStatus));
                    }
                    if (e.PropertyName == "NextExecuteDateTime")
                    {
                        //發生變更的屬性為TimersTimerStorage.NextExecuteDateTime
                        Console.WriteLine(String.Format("{0} 的 下一次執行時間已變更為 {1}", timerStorageBase.GetType().FullName,
                            timerStorageBase.NextExecuteDateTime.HasValue ? timerStorageBase.NextExecuteDateTime.Value.ToString("yyyy/MM/dd HH:mm:ss") : "不再執行"));
                    }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimerManager.getManagedTimerStorage``1(``0)">
            <summary>
            依照執行的事件執行個體，取得該執行個體的排程器清單
            </summary>
            <typeparam name="TTimerEvent">排程器所相依的事件執行個體型別</typeparam>
            <param name="timerEvent">排程器所相依的事件執行個體</param>
            <returns>相依的排程器清單</returns>
            <remarks>
            此方法屬於指標型(Reference Type)比對，在同一個類型(class)所產生的物件將被視為不同的個體；
            若要依照型別(<see cref="T:System.Type"/>)取得相依的排程器清單，請參考<see cref="M:TEC.Core.Scheduler.Timers.TimerManager.getManagedTimerStorage(System.Type)"/>
            </remarks>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimerManager.getManagedTimerStorage(System.Type)">
            <summary>
            依照執行的事件執行個體型別，取得該執行個體的排程器清單
            </summary>
            <param name="timerEventType">排程器所相依的事件的<see cref="T:System.Type"/></param>
            <returns>相依的排程器清單</returns>
            <remarks>
            此方法屬於事件型別(<see cref="T:System.Type"/>)比對，同一個類型(class)所產生的物件將被視為相同的個體；
            若要依照執行個體(Reference)取得相依的排程器清單，請參考<see cref="M:TEC.Core.Scheduler.Timers.TimerManager.getManagedTimerStorage``1(``0)"/>
            </remarks>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimerManager.Dispose(System.Boolean)">
            <summary>
            釋放目前物件的資源，此動作將終止所有受此物件管理的排程器，並釋放其資源。
            </summary>
            <param name="isDisposing">是否開始處理物件的資源釋放行為</param>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimerManager.Dispose">
            <summary>
            執行與釋放 (Free)、釋放 (Release) 或重設 Unmanaged 資源相關聯之應用程式定義的工作
            </summary>
        </member>
        <member name="P:TEC.Core.Scheduler.Timers.TimerManager.ManagedTimerReadOnlyObservableCollection">
            <summary>
            取得受管理的Timer唯讀集合
            </summary>
        </member>
        <member name="P:TEC.Core.Scheduler.Timers.TimerManager.ManagedTimerObservableCollection">
            <summary>
            取得受管理的Timer集合(Thread-Safe)
            </summary>
        </member>
        <member name="P:TEC.Core.Scheduler.Timers.TimerManager.TimersTimerStorageList">
            <summary>
            取得受管理的<see cref="T:TEC.Core.Scheduler.Timers.TimersTimerStorage"/> <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
        </member>
        <member name="T:TEC.Core.Scheduler.Timers.TimerStatus">
            <summary>
            排程器狀態的列舉
            </summary>
        </member>
        <member name="F:TEC.Core.Scheduler.Timers.TimerStatus.NotStart">
            <summary>
            尚未啟動
            </summary>
        </member>
        <member name="F:TEC.Core.Scheduler.Timers.TimerStatus.Pending">
            <summary>
            排程中
            </summary>
        </member>
        <member name="F:TEC.Core.Scheduler.Timers.TimerStatus.Executing">
            <summary>
            執行中
            </summary>
        </member>
        <member name="F:TEC.Core.Scheduler.Timers.TimerStatus.Stopped">
            <summary>
            已結束
            </summary>
        </member>
        <member name="T:TEC.Core.Scheduler.Timers.TimersTimerStorage">
            <summary>
            封裝<see cref="T:System.Timers.Timer"/>的排程器類別，此類別不能被繼承
            </summary>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimersTimerStorage.#ctor(TEC.Core.Scheduler.Timers.ITimerEvent,Itenso.TimePeriod.ITimePeriodCollection,System.ComponentModel.ISynchronizeInvoke,System.TimeSpan,TEC.Core.Scheduler.Timers.NextTimeEvaluationType)">
            <summary>
            初始化<see cref="T:System.Timers.Timer"/>資訊的物件，並指定這個工作的有效時間區間
            </summary>
            <param name="timerEvent">當每次時間重置時要執行的事件</param>
            <param name="timePeriodCollection">對於這個<see cref="T:System.Timers.Timer"/>而言，有效的執行區間</param>
            <param name="synchronizingObject">用來封送處理事件處理常式的呼叫 (當間隔已經耗盡時所發出)，若不需要則為<c>null</c></param>
            <param name="timeSpan">每次時間逾期重置的間隔</param>
            <param name="nextTimeEvaluationType">下次執行時間的基礎，當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.ExecutionEndTime"/>時，以每次執行完成後，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>為下次執行時間。
            當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.StartUpTime"/>時，以第一次執行時間為主，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>的倍數至未來最接近現在的時間為下次執行時間。主要差別在於後者時間不會偏移主要執行時間。</param>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimersTimerStorage.#ctor(TEC.Core.Scheduler.Timers.ITimerEvent,Itenso.TimePeriod.ITimePeriodCollection,System.ComponentModel.ISynchronizeInvoke,System.Int32,TEC.Core.Scheduler.Timers.NextTimeEvaluationType)">
            <summary>
            初始化<see cref="T:System.Timers.Timer"/>資訊的物件，並指定這個工作的有效時間區間
            </summary>
            <param name="timerEvent">當每次時間重置時要執行的事件</param>
            <param name="timePeriodCollection">對於這個<see cref="T:System.Timers.Timer"/>而言，有效的執行區間</param>
            <param name="synchronizingObject">用來封送處理事件處理常式的呼叫 (當間隔已經耗盡時所發出)，若不需要則為<c>null</c></param>
            <param name="interval">每次時間逾期重置的間隔(以毫秒為單位 1000毫秒=1秒)</param>
            <param name="nextTimeEvaluationType">下次執行時間的基礎，當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.ExecutionEndTime"/>時，以每次執行完成後，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>為下次執行時間。
            當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.StartUpTime"/>時，以第一次執行時間為主，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>的倍數至未來最接近現在的時間為下次執行時間。主要差別在於後者時間不會偏移主要執行時間。</param>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimersTimerStorage.#ctor(TEC.Core.Scheduler.Timers.ITimerEvent,Itenso.TimePeriod.ITimePeriodCollection,System.Int32,TEC.Core.Scheduler.Timers.NextTimeEvaluationType)">
            <summary>
            初始化<see cref="T:System.Timers.Timer"/>資訊的物件，並指定這個工作的有效時間區間
            </summary>
            <param name="timerEvent">當每次時間重置時要執行的事件</param>
            <param name="timePeriodCollection">對於這個<see cref="T:System.Timers.Timer"/>而言，有效的執行區間</param>
            <param name="interval">每次時間逾期重置的間隔(以毫秒為單位 1000毫秒=1秒)</param>
            <param name="nextTimeEvaluationType">下次執行時間的基礎，當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.ExecutionEndTime"/>時，以每次執行完成後，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>為下次執行時間。
            當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.StartUpTime"/>時，以第一次執行時間為主，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>的倍數至未來最接近現在的時間為下次執行時間。主要差別在於後者時間不會偏移主要執行時間。</param>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimersTimerStorage.TimersTimer_Elapsed(System.Object,System.Timers.ElapsedEventArgs)">
            <summary>
            當<see cref="T:System.Timers.Timer"/>啟動時引發之事件，此事件用於變更Timer狀態
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimersTimerStorage.start">
            <summary>
            開始計時器。
            </summary>
            <remarks>
            若您需要捕捉執行排程器事件(<see cref="T:TEC.Core.Scheduler.Timers.ITimerEvent"/>)時發生的例外，請繫結<see cref="E:TEC.Core.Scheduler.Timers.TimersTimerStorage.OnUnhandledExceptionThrew"/>事件。
            </remarks>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimersTimerStorage.evaluateStarting">
            <summary>
            評估是否開始計時器，若可以開始則立即開始，若沒有下次執行的時間則停止執行。
            </summary>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimersTimerStorage.Dispose(System.Boolean)">
            <summary>
            釋放目前物件的資源
            </summary>
            <param name="isDisposing">是否開始處理物件的資源釋放行為</param>
        </member>
        <member name="P:TEC.Core.Scheduler.Timers.TimersTimerStorage.Timer">
            <summary>
            取得與此物件相關聯的<see cref="T:System.Timers.Timer"/>
            </summary>
        </member>
        <member name="E:TEC.Core.Scheduler.Timers.TimersTimerStorage.OnUnhandledExceptionThrew">
            <summary>
            當在執行排程事件時，有未處理的例外狀況發生時引發
            </summary>
        </member>
        <member name="T:TEC.Core.Scheduler.Timers.TimerStorageBase">
            <summary>
            Timer介接所使用的基底儲存類別
            </summary>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimerStorageBase.#ctor(TEC.Core.Scheduler.Timers.ITimerEvent,Itenso.TimePeriod.ITimePeriodCollection,System.TimeSpan,TEC.Core.Scheduler.Timers.NextTimeEvaluationType)">
            <summary>
            初始化Timer資訊的物件，並指定這個工作的有效時間區間
            </summary>
            <param name="timePeriodCollection">對於這個排程而言，有效的執行區間</param>
            <param name="interval">每次執行的間隔</param>
            <param name="nextTimeEvaluationType">下次執行時間的基礎，當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.ExecutionEndTime"/>時，以每次執行完成後，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>為下次執行時間。
            當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.StartUpTime"/>時，以第一次執行時間為主，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>的倍數至未來最接近現在的時間為下次執行時間。主要差別在於後者時間不會偏移主要執行時間。</param>
            <param name="timerEvent">排定執行的內容</param>
            <exception cref="T:System.ArgumentNullException">當<paramref name="timePeriodCollection"/>或<paramref name="timerEvent"/>為<c>null</c>時擲出</exception>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimerStorageBase.getNextExecuteDateTime(System.Int32,System.DateTime)">
            <summary>
            取得從指定基準時間(不含)向後算指定次數執行工作的時間清單
            </summary>
            <param name="maxCount">最大執行數</param>
            <param name="baseDateTime">起始搜尋點</param>
            <returns>傳回小於或等於<paramref name="maxCount"/>的執行時間</returns>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimerStorageBase.updateNextExecuteTime">
            <summary>
            以<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.NextExecuteDateTime"/>為基礎，移動至下一個執行的時間，如果沒有下一次的執行時間則傳回<c lang="C#">null</c>
            </summary>
            <returns>傳回移動完成的下一次執行時間，若無則為null</returns>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimerStorageBase.Dispose(System.Boolean)">
            <summary>
            釋放目前物件的資源
            </summary>
            <param name="isDisposing">是否開始處理物件的資源釋放行為</param>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimerStorageBase.Dispose">
            <summary>
            執行與釋放 (Free)、釋放 (Release) 或重設 Unmanaged 資源相關聯之應用程式定義的工作
            </summary>
        </member>
        <member name="M:TEC.Core.Scheduler.Timers.TimerStorageBase.start">
            <summary>
            開始計時器
            </summary>
        </member>
        <member name="P:TEC.Core.Scheduler.Timers.TimerStorageBase.NextExecuteDateTime">
            <summary>
            下一次執行工作的時間，若無則為 <c lang="C#">null</c> 參考。[值變更時引發通知]
            </summary>
        </member>
        <member name="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval">
            <summary>
            設定或取得執行的間隔 [值變更時引發通知]
            </summary>
        </member>
        <member name="P:TEC.Core.Scheduler.Timers.TimerStorageBase.NextTimeEvaluationType">
            <summary>
            設定或取得評估下次執行時間的基礎，當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.ExecutionEndTime"/>時，以每次執行完成後，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>為下次執行時間。
            當值為<see cref="F:TEC.Core.Scheduler.Timers.NextTimeEvaluationType.StartUpTime"/>時，以第一次執行時間為主，加上<see cref="P:TEC.Core.Scheduler.Timers.TimerStorageBase.Interval"/>的倍數至未來最接近現在的時間為下次執行時間。主要差別在於後者時間不會偏移主要執行時間。
            [值變更時引發通知]
            </summary>
        </member>
        <member name="P:TEC.Core.Scheduler.Timers.TimerStorageBase.TimerStatus">
            <summary>
            取得與此排程器相關聯的狀態 [值變更時引發通知]
            </summary>
        </member>
        <member name="P:TEC.Core.Scheduler.Timers.TimerStorageBase.ITimerEvent">
            <summary>
            取得排定執行的動作物件
            </summary>
        </member>
        <member name="P:TEC.Core.Scheduler.Timers.TimerStorageBase.TimePeriodCollection">
            <summary>
            取得與此排程相關的執行有效時間
            </summary>
        </member>
        <member name="P:TEC.Core.Scheduler.Timers.TimerStorageBase.IsDisposed">
            <summary>
            取得物件是否已經完成清理 [值變更時引發通知]
            </summary>
        </member>
        <member name="F:TEC.Core.Scheduler.Timers.TimerStorageBase.Disposed">
            <summary>
            當此元件被處置完成時發生。
            </summary>
        </member>
    </members>
</doc>
